#line 1 "/mat/megascans_shader_simple1/SurfaceVexCode"
#line 15 "/mat/megascans_shader_simple1/SurfaceVexCode"
_Pragma("opname megascans_shader_simple1");
_Pragma("oplabel \"Local Vop Code\"");
_Pragma("opmininputs 0");
_Pragma("opmaxinputs 0");
_Pragma("label	uv	\"\"");
_Pragma("hint	uv	invisible");
_Pragma("label	st	\"\"");
_Pragma("hint	st	invisible");
#line 33 "/mat/megascans_shader_simple1/SurfaceVexCode"
_Pragma("label	ao_texture	\"\"");
_Pragma("hint	ao_texture	image");
_Pragma("hidewhen	ao_texture	{ ao_texture == \"\" }");
_Pragma("label	albedo_texture	\"\"");
_Pragma("hint	albedo_texture	image");
_Pragma("hidewhen	albedo_texture	{ albedo_texture == \"\" }");
_Pragma("label	ior_texture	\"\"");
_Pragma("hint	ior_texture	image");
_Pragma("hidewhen	ior_texture	{ ior_texture == \"\" }");
_Pragma("label	rough_texture	\"\"");
_Pragma("hint	rough_texture	image");
_Pragma("hidewhen	rough_texture	{ rough_texture == \"\" }");
_Pragma("label	rough	\"Rough Scale\"");
_Pragma("range	rough	0	1");
_Pragma("label	reflect_texture	\"\"");
_Pragma("hint	reflect_texture	image");
_Pragma("hidewhen	reflect_texture	{ reflect_texture == \"\" }");
_Pragma("label	layer	\"\"");
_Pragma("hint	layer	invisible");
_Pragma("label	bump_texture	\"\"");
_Pragma("hint	bump_texture	image");
_Pragma("hidewhen	bump_texture	{ bump_texture == \"\" }");
_Pragma("label	normal_texture	\"\"");
_Pragma("hint	normal_texture	image");
_Pragma("hidewhen	normal_texture	{ normal_texture == \"\" }");
_Pragma("label	disp_texture	\"\"");
_Pragma("hint	disp_texture	image");
_Pragma("hidewhen	disp_texture	{ disp_texture == \"\" }");
_Pragma("label	dispTex_scale	\"Displace Scale\"");
_Pragma("range	dispTex_scale	0	1");

_Pragma("label	trans_texture	\"\"");
_Pragma("hint	trans_texture	image");
_Pragma("hidewhen	trans_texture	{ trans_texture == \"\" }");

_Pragma("label	opaccolor_texture	\"\"");
_Pragma("hint	opaccolor_texture	image");
_Pragma("hidewhen	opaccolor_texture	{ opaccolor_texture == \"\" }");


_Pragma("label	reflect_scale	\"Reflect Scale\"");
_Pragma("range	reflect_scale	0	1");
_Pragma("label	Shift	\"Hue Shift\"");
_Pragma("range	Shift	-1	1");
_Pragma("hidewhen	Shift	{ albedo_texture == \"\" }");
_Pragma("label	Saturation	Saturation");
_Pragma("range	Saturation	0	10");
_Pragma("hidewhen	Saturation	{ albedo_texture == \"\" }");
_Pragma("label	Value	Value");
_Pragma("range	Value	0	10");
_Pragma("hidewhen	Value	{ albedo_texture == \"\" }");
_Pragma("label	Bias	Bias");
_Pragma("hidewhen	Bias	{ albedo_texture == \"\" }");
_Pragma("label	Gain	Gain");
_Pragma("hidewhen	Gain	{ albedo_texture == \"\" }");
_Pragma("label	Gamma	Gamma");
_Pragma("range	Gamma	0	10");
_Pragma("hidewhen	Gamma	{ albedo_texture == \"\" }");

_Pragma("label	use_opacity	\"\"");
_Pragma("hint	use_opacity	toggle");
_Pragma("label	layer_mask	\"\"");
_Pragma("hint	layer_mask	invisible");
_Pragma("range	layer_mask	0	1");
_Pragma("label	addative_displace	\"Input Number 2\"");
_Pragma("hint	addative_displace	invisible");
_Pragma("hint	addative_displace	nolabel");
_Pragma("range	addative_displace	0	1");
_Pragma("label	dispoffset	\"Offset Displace\"");
_Pragma("range	dispoffset	0	1");
#line 118 "/mat/megascans_shader_simple1/SurfaceVexCode"
_Pragma("label	Oc	\"\"");
_Pragma("hint	Oc	invisible");
_Pragma("label	Cv	\"\"");
_Pragma("hint	Cv	invisible");
_Pragma("label	Th	\"\"");
_Pragma("hint	Th	invisible");
_Pragma("label	Ab	\"\"");
_Pragma("hint	Ab	invisible");
_Pragma("label	Cu	\"\"");
_Pragma("hint	Cu	invisible");
_Pragma("label	Vd	\"\"");
_Pragma("hint	Vd	invisible");
_Pragma("label	Nt	\"\"");
_Pragma("hint	Nt	invisible");
_Pragma("label	Ds	\"\"");
_Pragma("hint	Ds	invisible");
_Pragma("label	Vdt	\"\"");
_Pragma("hint	Vdt	invisible");




_Pragma("label	metallic_texture	\"\"");
_Pragma("hint	metallic_texture	image");
_Pragma("hidewhen	metallic_texture	{ metallic_texture == \"\" }");
_Pragma("label	normal_mult	\"Normal Bump Multiply\"");
_Pragma("range	normal_mult	0	1");
_Pragma("parmhelp	normal_mult	'multiply normal by dispscale'");
_Pragma("hidewhen	normal_mult	{ normal_texture == \"\" }");
_Pragma("label	dmultopacity	\"Displace Premultiply\"");
_Pragma("hint	dmultopacity	toggle");
_Pragma("hint	dmultopacity	joinnext");
_Pragma("label	simplify_bsdf	\"Simplify BSDF\"");
_Pragma("hint	simplify_bsdf	toggle");





#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
#line 22 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
struct ShaderExports
{
    string	names_f[];
    float	values_f[];
    string	names_v[];
    vector	values_v[];
    string	names_v4[];
    vector4	values_v4[];
}

struct ShaderLayer
{
    bsdf	    F;
    vector	    Of;
    vector	    Ce;
    vector	    P;
    vector	    N;
    float	    layeralpha;
    float	    thickness;
    vector	    absorption;
    float	    masks[];
    ShaderExports   exports;
}

void init_layerexports(export ShaderExports exports)
{
    exports.names_f = {};
    exports.values_f = {};
    exports.names_v = {};
    exports.values_v = {};
    exports.names_v4 = {};
    exports.values_v4 = {};
}

void init_layer(export ShaderLayer layer)
{
    layer.F = bsdf();
    layer.Of = {1,1,1};
    layer.Ce = {0,0,0};
    layer.P = P;
    layer.N = normalize(N);
    layer.layeralpha = 1.0;
    layer.masks = {};
    init_layerexports(layer.exports);
}
#line 135 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
void comp_export_arrays_aoverb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a+(1-Aa)*Ba*val_b); } } void comp_export_arrays_ainsideb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba); } } void comp_export_arrays_aoutsideb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba)); } } void comp_export_arrays_aatopb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba + Ba*val_b*(1-Aa)); } } void comp_export_arrays_axorb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba) + Ba*val_b*(1-Aa)); } }
void comp_export_arrays_aoverb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a+(1-Aa)*Ba*val_b); } } void comp_export_arrays_ainsideb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba); } } void comp_export_arrays_aoutsideb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba)); } } void comp_export_arrays_aatopb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba + Ba*val_b*(1-Aa)); } } void comp_export_arrays_axorb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba) + Ba*val_b*(1-Aa)); } }
void comp_export_arrays_aoverb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a+(1-Aa)*Ba*val_b); } } void comp_export_arrays_ainsideb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba); } } void comp_export_arrays_aoutsideb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba)); } } void comp_export_arrays_aatopb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba + Ba*val_b*(1-Aa)); } } void comp_export_arrays_axorb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba) + Ba*val_b*(1-Aa)); } }
#line 160 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
void composite_exports_aoverb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_aoverb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_aoverb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_aoverb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_ainsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_ainsideb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_ainsideb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_ainsideb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_aoutsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_aoutsideb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_aoutsideb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_aoutsideb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_aatopb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_aatopb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_aatopb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_aatopb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_axorb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_axorb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_axorb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_axorb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
#line 200 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
ShaderLayer composite_aoverb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F+(1-Aa)*Ba*B.F; C.Of = Aa*A.Of+(1-Aa)*Ba*B.Of; C.Ce = Aa*A.Ce+(1-Aa)*Ba*B.Ce; C.P = Aa*A.P+(1-Aa)*Ba*B.P; C.N = normalize(Aa*A.N+(1-Aa)*Ba*B.N); C.layeralpha = Aa+(1-Aa)*Ba; composite_exports_aoverb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a+(1-Aa)*Ba*mask_b; } return C; } ShaderLayer composite_aoverb(const ShaderLayer A; const ShaderLayer B) { return composite_aoverb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_ainsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*Ba; C.Of = Aa*A.Of*Ba; C.Ce = Aa*A.Ce*Ba; C.P = Aa*A.P*Ba; C.N = normalize(Aa*A.N*Ba); C.layeralpha = Aa*Ba; composite_exports_ainsideb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*Ba; } return C; } ShaderLayer composite_ainsideb(const ShaderLayer A; const ShaderLayer B) { return composite_ainsideb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_aoutsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*(1-Ba); C.Of = Aa*A.Of*(1-Ba); C.Ce = Aa*A.Ce*(1-Ba); C.P = Aa*A.P*(1-Ba); C.N = normalize(Aa*A.N*(1-Ba)); C.layeralpha = Aa*(1-Ba); composite_exports_aoutsideb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*(1-Ba); } return C; } ShaderLayer composite_aoutsideb(const ShaderLayer A; const ShaderLayer B) { return composite_aoutsideb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_aatopb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*Ba + Ba*B.F*(1-Aa); C.Of = Aa*A.Of*Ba + Ba*B.Of*(1-Aa); C.Ce = Aa*A.Ce*Ba + Ba*B.Ce*(1-Aa); C.P = Aa*A.P*Ba + Ba*B.P*(1-Aa); C.N = normalize(Aa*A.N*Ba + Ba*B.N*(1-Aa)); C.layeralpha = Ba; composite_exports_aatopb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*Ba + Ba*mask_b*(1-Aa); } return C; } ShaderLayer composite_aatopb(const ShaderLayer A; const ShaderLayer B) { return composite_aatopb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_axorb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*(1-Ba) + Ba*B.F*(1-Aa); C.Of = Aa*A.Of*(1-Ba) + Ba*B.Of*(1-Aa); C.Ce = Aa*A.Ce*(1-Ba) + Ba*B.Ce*(1-Aa); C.P = Aa*A.P*(1-Ba) + Ba*B.P*(1-Aa); C.N = normalize(Aa*A.N*(1-Ba) + Ba*B.N*(1-Aa)); C.layeralpha = Aa+Ba-2*(Aa*Ba); composite_exports_axorb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*(1-Ba) + Ba*mask_b*(1-Aa); } return C; } ShaderLayer composite_axorb(const ShaderLayer A; const ShaderLayer B) { return composite_axorb(A, A.layeralpha, B, B.layeralpha); }
#line 216 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
void set_layer_export(ShaderLayer layer; string name; float value) { int index = find(layer.exports.names_f, name); if(index < 0) index = len(layer.exports.names_f); layer.exports.names_f[index] = name; layer.exports.values_f[index] = value; }
void set_layer_export(ShaderLayer layer; string name; vector value) { int index = find(layer.exports.names_v, name); if(index < 0) index = len(layer.exports.names_v); layer.exports.names_v[index] = name; layer.exports.values_v[index] = value; }
void set_layer_export(ShaderLayer layer; string name; vector4 value) { int index = find(layer.exports.names_v4, name); if(index < 0) index = len(layer.exports.names_v4); layer.exports.names_v4[index] = name; layer.exports.values_v4[index] = value; }
#line 157 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 159 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet10(int val1; string val2)
{
    if(val2 !=""){
    val1=1;
    }
    else{
    val1=0;
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 173 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 45 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shading.h"
#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 22 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shading.h"
#line 36 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shading.h"
vector
shading_computeEnvAngleScale(vector dir; vector axis; float anglescale)
{
    vector	ndir;

    if (anglescale != 1)
    {
	float	zangle = acos(dir.z);
	vector	raxis;
	matrix3	rmat;

	raxis = normalize(cross(axis, dir));
	if (anglescale > 0)
	{
	    zangle /= anglescale;
	    zangle = clamp(zangle, 0.0, 3.1415926);
	}
	else
	    zangle = 3.1415926;

	rmat = ident();
	rotate(rmat, zangle, raxis);

	ndir = axis * rmat;
    }
    else
	ndir = dir;

    return ndir;
}


vector fresnelcond_nmin(vector r)
{
    return (1-r)/(1+r);
}

vector fresnelcond_nmax(vector r)
{
    return (1+sqrt(r))/(1-sqrt(r));
}

vector fresnelcond_eta(vector r, g)
{
    return fresnelcond_nmin(r)*g + (1-g)*fresnelcond_nmax(r);
}

vector fresnelcond_kappa2(vector r, n)
{
    vector nr = (n+1)*(n+1)*r-(n-1)*(n-1);
    return nr/(1-r);
}

vector fresnelcond_reflectivity(vector n, k)
{
    return ((n-1)*(n-1)+k*k)/((n+1)*(n+1)+k*k);
}

vector fresnelcond_edgetint(vector n, r)
{
    return (fresnelcond_nmax(r)-n)/(fresnelcond_nmax(r)-fresnelcond_nmin(r));
}


vector fresnelcond_artistic(vector nI, nN, r, g)
{
    float dotNI = clamp(dot(nN, -nI), 0, 0.999);

    vector n = fresnelcond_eta(r, g);
    vector k2 = fresnelcond_kappa2(r, n);

    vector rs_num = n*n + k2 - 2*n*dotNI + dotNI*dotNI;
    vector rs_den = n*n + k2 + 2*n*dotNI + dotNI*dotNI;
    vector rs = rs_num/rs_den;

    vector rp_num = (n*n + k2)*dotNI*dotNI - 2*n*dotNI + 1;
    vector rp_den = (n*n + k2)*dotNI*dotNI + 2*n*dotNI + 1;
    vector rp = rp_num/rp_den;

    return 0.5*(rs+rp);
}




vector fresnelcond_physical(vector nI, nN, eta, kappa)
{
    float dotNI = clamp(dot(nN, -nI), 0, 0.999);

    vector tmp = (eta*eta + kappa*kappa) * dotNI*dotNI;
    vector Rparl2 = (tmp - (2.0f * eta * dotNI) + 1) /
                    (tmp + (2.0f * eta * dotNI) + 1);
    vector tmp_f = eta*eta + kappa*kappa;
    vector Rperp2 = (tmp_f - (2.0f * eta * dotNI) + dotNI*dotNI) /
                    (tmp_f + (2.0f * eta * dotNI) + dotNI*dotNI);
    return 0.5 * (Rparl2 + Rperp2);
}

void thinfresnel(const vector nI, nN; const float eta; export float kr, kt)
{
    float kr1, kt1;
    vector R1, T1;
    fresnel(nI, nN, eta, kr1, kt1, R1, T1);

    float kr2, kt2;
    vector R2, T2;
    fresnel(T1, nN, eta, kr2, kt2);

    float tmp = 1.0/(1 - kr2*kr2);
    kr = kr1 + (kt1*kr2*kt2) * tmp;
    kt = kt1*kt2*tmp;
}

void thinfresnel(const vector nI, nN; const float eta; export float kr, kt; export vector R, T)
{
    thinfresnel(nI, nN, eta, kr, kt);

    R = reflect(nI, nN);
    T = nI;
}


float
dirtmask_dome(vector P;
	 vector nN;
	 int inSID;
	 int	samples;
	 float  maxdist;
	 vector biasdir;
	 float  bias;
	 string scope)
{
    int hit, found;
    float dist;
    vector localdir, dir, hitP, hitN;

    vector u = normalize(set(nN.z, nN.z, -nN.x-nN.y));
    vector v = normalize(cross(nN, u));
    matrix3 space = set(u, v, nN);

    float _maxdist;
    vector _biasdir = biasdir;
    _biasdir = ntransform("space:world", "space:current", _biasdir);
    _biasdir = normalize(select(bias >= 0, -_biasdir, _biasdir));
    float _bias = abs(bias);

    int hits = 0;
    vector2 sample;

    float raybias;
    found = renderstate("renderer:raybias", raybias);
    raybias = select(found, raybias, 1e-3);

    string rengine;
    renderstate("renderer:renderengine", rengine);
    int israytrace = rengine == "raytrace" || rengine == "pbrraytrace";
    int sid = israytrace ? inSID : newsampler();

    for(int i=0; i<samples; i++)
    {
	if (israytrace)
	    nextsample(sid, sample.x, sample.y, "mode", "nextpixel");
	else
	    nextsample(sid, sample.x, sample.y, "mode", "qstrat");

	float phi = 2.0*3.1415926*sample.x;
	float theta = asin(sqrt(sample.y));

	localdir.x = cos(theta) * sin(phi);
	localdir.y = cos(theta) * cos(phi);
	localdir.z = sin(theta);
	dir = localdir * space;

	float dotbias = dot(dir, _biasdir);
	float dotNB = dot(nN, _biasdir);
	_biasdir = _biasdir - clamp(dotNB, -1, 0) * nN;
	dir += _bias * clamp(dotbias, 0, 1) * _biasdir;
	dir *= fit(dotbias, -2, 1, 1.0/(1.0+_bias), 1);
	dir = normalize(dir);

	vector testNg = normalize(select(dot(nN, Ng) > 0.0, Ng, -Ng));
	if (dot(dir, testNg) < 1e-5)
		continue;

	dist = rayhittest(P, maxdist * dir, hitP, hitN, raybias, "scope", scope);
	hit = dist >= 0.0;

	hits += hit;
    }

    return (float)hits/samples;
}

float
dirtmask_fan(vector P;
	 vector nN;
	 int inSID;
	 float  sensitivity;
	 int	samples;
	 float  maxdist;
	 vector biasdir;
	 float  bias;
	 string scope)
 {
    int hit, found;
    float dist;
    vector localdir, dir, hitP, hitN;

    vector u = normalize(set(nN.z, nN.z, -nN.x-nN.y));
    vector v = normalize(cross(nN, u));
    matrix3 space = set(u, v, nN);

    float max_dirt = 0.0;

    vector2 sample;
    float _maxdist;
    vector _biasdir = normalize(select(bias >= 0, -biasdir, biasdir));
    _biasdir = ntransform("space:world", "space:current", _biasdir);
    float _bias = abs(bias);

    float raybias;
    found = renderstate("renderer:raybias", raybias);
    raybias = select(found, raybias, 1e-3);

    string rengine;
    renderstate("renderer:renderengine", rengine);
    int israytrace = rengine == "raytrace" || rengine == "pbrraytrace";
    int sid = israytrace ? inSID : newsampler();

    for(int i=0; i<samples; i++)
    {
	if (israytrace)
	    nextsample(sid, sample.x, sample.y, "mode", "nextpixel");
	else
	    nextsample(sid, sample.x, sample.y, "mode", "qstrat");

	float phi = 2.0 * 3.1415926 * sample.x;
	float theta = 0.5*3.1415926*sensitivity;

	localdir.x = cos(phi);
	localdir.y = sin(phi);
	localdir.z = 0;

	dir = localdir * space;

	float dotNB = dot(nN, _biasdir);
	_biasdir = _biasdir - dotNB * nN;
	float dotbias = dot(dir, normalize(_biasdir));
	dir += _bias * clamp(dotbias, 0, 1) * _biasdir;
	dir *= fit(dotbias, -2, 1, 1.0/(1.0+_bias), 1);

	float len = length(dir);
	dir *= sin(theta);
	dir += fit01(sin(theta), 1, len) * cos(theta) * nN;
	dir = normalize(dir);

	dist = rayhittest(P, maxdist * dir, hitP, hitN, raybias, "scope", scope);

	hit = dist >= 0.0;

	float dirt = clamp(1.0 - dist / (maxdist * length(dir)), 0, 1);
	max_dirt = select(hit, max(dirt, max_dirt), max_dirt);
    }

    return max_dirt;
}
#line 46 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 97 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
float
vop_grandom(float u0, u1; float sigma)
{



    return cos(u0 * (3.1415926*2)) * sqrt(-2 * log(u1)) * sigma;
}
float
vop_grandom(int seed; float sigma)
{
    float	u0 = random(seed);
    float	u1 = random(seed*3929 + 48311);
    return vop_grandom(u0, u1, sigma);
}

float
vop_gnrandom(float sigma)
{
    float	u0 = nrandom();
    float	u1 = nrandom();
    return vop_grandom(u0, u1, sigma);
}

vector
vop_grandom(int seed; float sigma)
{


    float	x = float(vop_grandom(seed, sigma));
    float	y = float(vop_grandom(seed*17 + 97, sigma));
    float	z = float(vop_grandom(seed*29 + 383, sigma));
    return set(x, y, z);
}

vector
vop_gnrandom(float sigma)
{


    float	x = float(vop_gnrandom(sigma));
    float	y = float(vop_gnrandom(sigma));
    float	z = float(vop_gnrandom(sigma));
    return set(x, y, z);
}

void
vop_bindST(float news, ss; int isSConnected;
	   float newt, tt; int isTConnected)
{







    news = isSConnected ? ss : s;
    newt = isTConnected ? tt : t;




}

void
vop_bindS(float news, ss; int isSConnected)
{





    news = isSConnected ? ss : s;



}

void
vop_bindU(export float newu; const float u; int isUVConnected)
{





    newu = isUVConnected ? u : s;



}

void
vop_bindUV(export vector2 newuv; const vector2 uv; int isUVConnected)
{





    newuv = isUVConnected ? uv : set(s, t);



}

void
vop_bindUV(export vector newuv; const vector uv; int isUVConnected)
{





    newuv = isUVConnected ? uv : set(s, t, 0);



}




float
vop_bias(float base, bias)
{
    float val;
    if (base <= 0)
	val = 0;
    else if (base >= 1)
	val = 1;
    else
	val = bias / (((1.0 / base) - 2) * (1 - bias) + 1);
    return val;
}

float
vop_gain(float base, gain)
{
    float	val;
    if (base < 0.5)
	val = vop_bias(2*base, gain)*.5;
    else
	val = 1-vop_bias(2*(1-base), gain)*.5;
    return val;
}

vector
vop_colorLinearTransform(vector C;
                         string fromSpace;)
{
    vector Ct = C;

    if (fromSpace == "srgb")
    {
        for (int i = 0; i < 3; i++)
        {
            if (C[i] <= 0.04045) Ct[i] = C[i] / 12.92;
            else Ct[i] = pow((C[i] + 0.055) / 1.055, 2.4);
        }
    }

    else if (fromSpace == "linear")
    {
        for (int i = 0; i < 3; i++)
        {
            if (C[i] <= 0.0031308) Ct[i] = C[i] * 12.92;
            else Ct[i] = 1.055 * pow(C[i], 1.0/2.4) - 0.055;
        }
    }

    return Ct;
}

vector
vop_colormix(vector c1, c2; float bias; int adjust)
{
    vector	clr;
    if (adjust == 3)
	clr = cspline(bias, c1, c1, c2, c2);
    else if (adjust == 2)
	clr = lerp(c1, c2, float(smooth(0, 1, bias)));
    else if (adjust == 1)
	clr = lerp(c1, c2, float(clamp(bias, 0, 1)));
    else
	clr = lerp(c1, c2, bias);
    return clr;
}

void
vop_composite(string operation;
	      vector C; float Ca;
	      vector A; float Aa;
	      vector B; float Ba;
	     )
{
    if (operation == "AoverB")
    {
	C  = A  + (1-Aa)*B;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "AinsideB")
    {
	C  = A*Ba;
	Ca = Aa*Ba;
    }
    else if (operation == "AoutsideB")
    {
	C  = A*(1-Ba);
	Ca = Aa*(1-Ba);
    }
    else if (operation == "AatopB")
    {
	C  = A*Ba + B*(1-Aa);
	Ca = Ba;
    }
    else if (operation == "AxorB")
    {
	C  = A*(1-Ba) + B*(1-Aa);
	Ca = Aa + Ba - 2*(Aa*Ba);
    }
    else if (operation == "A")
    {
	C  = A;
	Ca = Aa;
    }
    else if (operation == "B")
    {
	C  = B;
	Ca = Ba;
    }
    else if (operation == "clear")
    {
	C  = 0;
	Ca = 0;
    }
    else if (operation == "multiply")
    {
	C  = A * B;
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "screen")
    {
	C  = A + B - A * B;
	C  = (1 - Aa) * B + Aa * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "overlay")
    {
	C = 2 * A * B;
	if (B.x > 0.5) C.x = 1.0 - 2.0 * (1.0-A.x) * (1.0-B.x);
	if (B.y > 0.5) C.y = 1.0 - 2.0 * (1.0-A.y) * (1.0-B.y);
	if (B.z > 0.5) C.z = 1.0 - 2.0 * (1.0-A.z) * (1.0-B.z);
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "darken")
    {
	C  = min(A, B);
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "lighten")
    {
	C  = max(A, B);
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "colordodge")
    {
	C = { 0.0, 0.0, 0.0 };
	if (B.x != 0.0) C.x = (A.x == 1.0) ? 1.0 : min(1.0, B.x / (1.0 - A.x));
	if (B.y != 0.0) C.y = (A.y == 1.0) ? 1.0 : min(1.0, B.y / (1.0 - A.y));
	if (B.z != 0.0) C.z = (A.z == 1.0) ? 1.0 : min(1.0, B.z / (1.0 - A.z));
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "colorburn")
    {
	C = { 1.0, 1.0, 1.0 };
	if (B.x != 1.0) C.x = (A.x == 0.0) ? 0.0 : 1.0 - min(1.0, (1.0-B.x) / A.x);
	if (B.y != 1.0) C.y = (A.y == 0.0) ? 0.0 : 1.0 - min(1.0, (1.0-B.y) / A.y);
	if (B.z != 1.0) C.z = (A.z == 0.0) ? 0.0 : 1.0 - min(1.0, (1.0-B.z) / A.z);
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "hardlight")
    {
	C = 2.0 * A * B;
	if (A.x > 0.5) C.x = 1.0 - 2.0 * (1-A.x) * (1-B.x);
	if (A.y > 0.5) C.y = 1.0 - 2.0 * (1-A.y) * (1-B.y);
	if (A.z > 0.5) C.z = 1.0 - 2.0 * (1-A.z) * (1-B.z);
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }

    else if (operation == "softlight")
    {
	C = B - (1.0 - 2.0 * A) * B * (1.0 - B);
	if (A.x > 0.5) C.x = B.x + (2.0 * A.x - 1.0) * (B.x <= 0.25 ? ((16.0 * B.x - 12.0) * B.x + 4.0) * B.x : sqrt(B.x) - B.x);
	if (A.y > 0.5) C.y = B.y + (2.0 * A.y - 1.0) * (B.y <= 0.25 ? ((16.0 * B.y - 12.0) * B.y + 4.0) * B.y : sqrt(B.y) - B.y);
	if (A.z > 0.5) C.z = B.z + (2.0 * A.z - 1.0) * (B.z <= 0.25 ? ((16.0 * B.z - 12.0) * B.z + 4.0) * B.z : sqrt(B.z) - B.z);
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "difference")
    {
	C  = abs(B - A);
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "exclusion")
    {
	C  = A + B - 2.0 * A * B;
	C  = (1 - Ba) * A + Ba * C;
	Ca = Aa + (1-Aa)*Ba;
    }
}

float
vop_ptlined(vector P1, P2, Q)
{
    return ptlined(P1, P2, Q);
}


float
vop_FilterWidth(float x)
{

    float du = Du(x);
    float dv = Dv(x);
    return max(sqrt(du*du + dv*dv), 1e-6);




}



float
vop_FilterAngle(vector dir)
{
    vector	du, dv;
    vector	a, b, c, d;
    vector	ac, bd;
    float	angle;

    du = 0.5*Du(dir);
    dv = 0.5*Dv(dir);

    a = dir-du-dv;
    b = dir+du-dv;
    c = dir+du+dv;
    d = dir-du+dv;

    ac = cross(a, c) / sqrt(length2(a)*length2(c));
    bd = cross(b, d) / sqrt(length2(b)*length2(d));
    angle = 0.5 * length(cross(ac, bd));

    return acos(1 - (0.5 / 3.1415926) * angle);
}

float
vop_Pulse(float edge0, edge1, x, fwidth; string filter)
{
    float	x0, x1;

    x0 = x  - fwidth*.5;
    x1 = x0 + fwidth;
    return max(0, (min(x1, edge1)-max(x0, edge0))/fwidth);
}

float
vop_FilteredSin(float x, fwidth)
{
    float	x0, x1;

    x0 = x - fwidth * .5;
    x1 = x + fwidth;
    return (-0.7071067)*lerp((cos(x1)-cos(x0))/fwidth, 0, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_FilteredSinD(float x)
{
    return vop_FilteredSin(x, vop_FilterWidth(x));
}

float
vop_FilteredCos(float x, fwidth)
{
    float	x0, x1;

    x0 = x - fwidth * .5;
    x1 = x + fwidth;
    return 0.7071067*lerp((sin(x1)-sin(x0))/fwidth, 0, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_FilteredCosD(float x)
{
    return vop_FilteredCos(x, vop_FilterWidth(x));
}

float
vop_PulseD(float edge0, edge1, x; string filter)
{
    return vop_Pulse(edge0, edge1, x, vop_FilterWidth(x), filter);
}

float
vop_PulseTrain(float edge0, x, fwidth)
{
    float	x0, x1;

    x0 = x  - fwidth*.5;
    x1 = x0 + fwidth;
    x0 = edge0*floor(x0) + min(edge0, frac(x0));
    x1 = edge0*floor(x1) + min(edge0, frac(x1));
    return lerp((x1-x0)/fwidth, edge0, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_PulseTrainD(float edge0, x)
{
    return vop_PulseTrain(edge0, x, vop_FilterWidth(x));
}

float
vop_RampTrain(float x, fwidth)
{
    float	x0, x1, f;
    x0 = x - fwidth*.5;
    x1 = x0 + fwidth;
    f = frac(x0); x0 = float(floor(x0)) + f*f;
    f = frac(x1); x1 = float(floor(x1)) + f*f;
    return .5*lerp((x1-x0)/fwidth, .5, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_RampTrainD(float x)
{
    return vop_RampTrain(x, vop_FilterWidth(x));
}

float
vop_IntegrateTent(float x)
{
    float	f;
    f = frac(x);
    if (f > .5) f = f*(2 - f) - .5;
    else	f = f*f;
    return .5*floor(x) + f;
}

float
vop_TentTrain(float x, fwidth)
{
    float	x0, x1;
    x0 = x - fwidth*.5;
    x1 = x0 + fwidth;
    x0 = vop_IntegrateTent(x0);
    x1 = vop_IntegrateTent(x1);
    return lerp((x1-x0)/fwidth, .5, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_TentTrainD(float x)
{
    return vop_RampTrain(x, vop_FilterWidth(x));
}

float
vop_DotStamp(float px, py, fwidth; string filter)
{
    float	d;
    d = px*px + py*py;
    return filterstep(1,d-fwidth,d+fwidth,"filter",filter);
}

float
vop_BumpStamp(float px, py, fwidth; string filter)
{
    float d  = px*px + py*py;
    return 1-smooth(0.0, 1.0, d);
}

float
vop_RoundCosStamp(float px, py, fwidth; float hexness, sides, power;
		    string filter)
{
    float	ss, tt;
    float	x0, x1;

    ss = atan(py, px);
    tt = px*px + py*py + hexness*pow(abs(1-cos(ss*(sides))), power);
    x0 = tt - fwidth*.5;
    x1 = x0 + fwidth;
    return filterstep(1,x0,x1,"filter",filter);
}

float
vop_RoundSinStamp(float px, py, fwidth; float hexness, sides, power;
		    string filter)
{
    float	ss, tt;
    float	x0, x1;

    ss = atan(py, px) - 3.1415926;
    tt = px*px + py*py + hexness*pow(abs(1-sin(ss*(sides))), power);
    x0 = tt - fwidth*.5;
    x1 = x0 + fwidth;
    return filterstep(1,x0,x1,"filter",filter);
}


float
vop_RingStamp(float px, py, iradius, oradius, fwidth; string filter)
{
    float	d;
    d = px*px + py*py;
    return vop_Pulse(iradius, oradius, d, fwidth, filter);
}

float
vop_BoxStamp(float px, py, fu, fv; string filter)
{
    float	dx;
    dx  = vop_Pulse(-1, 1, px, fu, filter);
    dx *= vop_Pulse(-1, 1, py, fv, filter);
    return dx;
}
#line 645 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
int
vop_TileGen(float u, v; float fx, fy, ox, oy, stagger, jitter)
{
    int		row;

    v = v*fy - oy;
    row = floor(v);
    u = u*fx - ox - stagger*row + jitter*random(row);
    return floor(u) + row*1984;
}

int
vop_HexTileGen(float u, v; float fx, fy, ox, oy)
{
    float	left, right;
    int		row, col;

    v   = v*fy - oy;
    row = floor(v);
    v  = frac(v);

    u = u*fx + ox;
    if (row & 1)
	u += .5;

    col = floor(u);
    u = frac(u);

    if (v > .5)
    {
	right = v - .5;
	left  = 1.5 - v;
	if (u > left)
	{
	    if (!(row & 1)) col++;
	    row++;
	    v -= 1;
	    u = fit(u, left, 1, 0, .5);
	}
	else if (u < right)
	{
	    if (row & 1) col--;
	    row++;
	    v -= 1;
	    u = fit(u, 0, right, 0.5, 1);
	}
	else u = fit(u, right, left, 0, 1);
    }
    v = (v*2+1)/3;
    return row * 938 + col;
}
#line 710 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
float
vop_aaCell2D(float ss, tt, jx, jy, bwidth, bsoft, centerx, centery;
		float f1, f2; int seed)
{
    float	p2x, p2y, x0;
    float	blur;
    vector	vp1, vp2;

    vnoise(ss, tt, jx, jy, seed, f1, f2, centerx, centery, p2x, p2y);

    vp1 = set(centerx, centery, 0);
    vp2 = set(p2x, p2y, 0);
    x0 = (f2-f1)*(f1+f2) / max(distance(vp1, vp2), 1e-6);

    blur = max(vop_FilterWidth(ss), vop_FilterWidth(tt)) * (1 + bsoft);

    return filterstep(bwidth,x0-blur,x0+blur,"filter","gauss");
}








float
vop_StampPattern(int   layers;
		 float dotsize;
		 float dj;
		 float softness;
		 float px, jx;
		 float py, jy;
		 float aux, jaux;
		 string spottype;
		 string filter;
		 float	floatseed;
	 )
{
    float	fwidth;
    float	lrandom;
    float	cx, cy, loff, dsize;
    float	fx, fy;
    float	djx, djy;
    float	du, dv;
    float	result;
    float	irad, idot;
    vector	pp;
    int		i;

    du = vop_FilterWidth(px) * softness;
    dv = vop_FilterWidth(py) * softness;
    fwidth = max(du, dv);
    result = 0;
    loff = 0;
    for (i = 0; i < layers; i++, loff += .5)
    {
	lrandom = random(i);
	pp = set(floor(px+loff), floor(py+loff),
		    1000.0*lrandom+500) + {.5, .5, .5};
	floatseed = random(pp);

	pp = vector(random(pp)) - .5;
	dsize = dotsize * (1-dj*floatseed);
	idot = 1/dsize;

	djy  = idot*(1 - dsize);
	djx  = (2*clamp(jx, 0, 1)) * djy;
	djy *= (2*clamp(jy, 0, 1));

	cx = pp.x * djx;
	cy = pp.y * djy;
	fx = cx - 2*(frac(px+loff) - .5)*idot;
	fy = cy - 2*(frac(py+loff) - .5)*idot;

	if (spottype == "ring")
	{
	    irad = 1-clamp(aux + (pp.z - .5)*jaux, 0, 1);
	    result = vop_RingStamp(fx, fy, irad, 1, fwidth, filter);
	}
	else if (spottype == "box")
	{
	    result = vop_BoxStamp(fx, fy, du, dv, filter);
	}
	else if (spottype == "hex")
	{
	    result = 1-vop_RoundCosStamp(fx, fy, fwidth, aux, 6, jaux, filter);
	}
	else if (spottype == "star")
	{
	    result = 1-vop_RoundSinStamp(fx, fy, fwidth, aux, 5, jaux, filter);
	}
	else if (spottype == "bump")
	{
	    result = vop_BumpStamp(fx, fy, fwidth, filter);
	}
	else
	{
	    result = 1-vop_DotStamp(fx, fy, fwidth, filter);
	}
    }
    floatseed = (floatseed - 0.5)*32000;
    return result;
}

float
vop_RipplePattern(float x, y, decay, toff)
{
    float	d;

    d = sqrt(x*x + y*y);
    return sin(d-toff) * exp(d*(-decay));
}
#line 850 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
vector
vop_FlowNoiseGradVV(vector pos; float flow; float delta)
{
    vector	result;

    result.x = flownoise(set(pos.x+delta,pos.y,pos.z), flow)
	     - flownoise(set(pos.x-delta,pos.y,pos.z), flow);

    result.y = flownoise(set(pos.x,pos.y+delta,pos.z), flow)
	     - flownoise(set(pos.x,pos.y-delta,pos.z), flow);

    result.z = flownoise(set(pos.x,pos.y,pos.z+delta), flow)
	     - flownoise(set(pos.x,pos.y,pos.z-delta), flow);

    result /= delta * 2;

    return result;
}

vector4
vop_FlowNoiseGradPP(vector4 pos; float flow; float delta)
{
    vector4	result;

    result.x = flownoise(set(pos.x+delta,pos.y,pos.z,pos.w), flow)
	     - flownoise(set(pos.x-delta,pos.y,pos.z,pos.w), flow);

    result.y = flownoise(set(pos.x,pos.y+delta,pos.z,pos.w), flow)
	     - flownoise(set(pos.x,pos.y-delta,pos.z,pos.w), flow);

    result.z = flownoise(set(pos.x,pos.y,pos.z+delta,pos.w), flow)
	     - flownoise(set(pos.x,pos.y,pos.z-delta,pos.w), flow);

    result.w = flownoise(set(pos.x,pos.y,pos.z,pos.w+delta), flow)
	     - flownoise(set(pos.x,pos.y,pos.z,pos.w-delta), flow);

    result /= delta * 2;

    return result;
}

vector
vop_FlowNoiseGrad3V(vector pos; float flow; float delta)
{
    matrix3	result;
    vector	final;
    vector	dx, dy, dz;

    dx = flownoise(set(pos.x+delta,pos.y,pos.z), flow)
	 - flownoise(set(pos.x-delta,pos.y,pos.z), flow);

    dy = flownoise(set(pos.x,pos.y+delta,pos.z), flow)
	 - flownoise(set(pos.x,pos.y-delta,pos.z), flow);

    dz = flownoise(set(pos.x,pos.y,pos.z+delta), flow)
	 - flownoise(set(pos.x,pos.y,pos.z-delta), flow);

    result = set(dx.x, dx.y, dx.z,
	       dy.x, dy.y, dy.z,
	       dz.x, dz.y, dz.z);

    result /= delta * 2;




    final = 0.577735;
    final *= result;

    return final;
}

vector4
vop_FlowNoiseGrad4P(vector4 pos; float flow; float delta)
{
    matrix	result;
    vector4	final;
    vector	dx, dy, dz, dw;

    dx = flownoise(set(pos.x+delta,pos.y,pos.z,pos.w), flow)
	 - flownoise(set(pos.x-delta,pos.y,pos.z,pos.w), flow);

    dy = flownoise(set(pos.x,pos.y+delta,pos.z,pos.w), flow)
	 - flownoise(set(pos.x,pos.y-delta,pos.z,pos.w), flow);

    dz = flownoise(set(pos.x,pos.y,pos.z+delta,pos.w), flow)
	 - flownoise(set(pos.x,pos.y,pos.z-delta,pos.w), flow);

    dw = flownoise(set(pos.x,pos.y,pos.z,pos.w+delta), flow)
	 - flownoise(set(pos.x,pos.y,pos.z,pos.w-delta), flow);

    result = set(dx.x, dx.y, dx.z, 0,
	       dy.x, dy.y, dy.z, 0,
	       dz.x, dz.y, dz.z, 0,
	       dw.x, dw.y, dw.z, 0);

    result /= delta * 2;




    final = 0.5;
    final *= result;

    return final;
}

float
vop_fbmlength_float(float val)
{
    return val;
}

float
vop_fbmlength_vector(vector val)
{
    return length(val);
}

float
vop_fbmlength_vector4(vector4 val)
{
    return length(val);
}
#line 1002 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
float
vop_fbmNoiseFF(float pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = vop_FilterWidth(pos);
    float	nval, pp = pos;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(float (xnoise(pp)) - 0.5); } else { nval += amp *(float (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(float (xnoise(pp)) - 0.5); } else { nval += blend*(float (noise(pp)) - 0.5); } }
    return nval;
}

float
vop_fbmNoiseFV(vector pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    float	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(float (xnoise(pp)) - 0.5); } else { nval += amp *(float (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(float (xnoise(pp)) - 0.5); } else { nval += blend*(float (noise(pp)) - 0.5); } }
    return nval;
}

float
vop_fbmNoiseFP(vector4 pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    float	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(float (xnoise(pp)) - 0.5); } else { nval += amp *(float (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(float (xnoise(pp)) - 0.5); } else { nval += blend*(float (noise(pp)) - 0.5); } }
    return nval;
}

vector
vop_fbmNoiseVF(float pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = vop_FilterWidth(pos);
    float	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(vector (xnoise(pp)) - 0.5); } else { nval += amp *(vector (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(vector (xnoise(pp)) - 0.5); } else { nval += blend*(vector (noise(pp)) - 0.5); } }
    return nval;
}

vector
vop_fbmNoiseVV(vector pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(vector (xnoise(pp)) - 0.5); } else { nval += amp *(vector (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(vector (xnoise(pp)) - 0.5); } else { nval += blend*(vector (noise(pp)) - 0.5); } }
    return nval;
}

vector
vop_fbmNoiseVP(vector4 pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(vector (xnoise(pp)) - 0.5); } else { nval += amp *(vector (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(vector (xnoise(pp)) - 0.5); } else { nval += blend*(vector (noise(pp)) - 0.5); } }
    return nval;
}



float
vop_fbmFlowNoiseFV(vector pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    float	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; float namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (float(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_float(namount) * vop_FlowNoiseGradVV (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(float(flownoise(pp, flowv)) - 0.5); }
    return nval;
}

float
vop_fbmFlowNoiseFP(vector4 pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    float	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; float namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (float(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_float(namount) * vop_FlowNoiseGradPP (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(float(flownoise(pp, flowv)) - 0.5); }
    return nval;
}

vector
vop_fbmFlowNoiseVV(vector pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; vector namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (vector(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_vector(namount) * vop_FlowNoiseGrad3V (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(vector(flownoise(pp, flowv)) - 0.5); }
    return nval;
}

vector
vop_fbmFlowNoiseVP(vector4 pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; vector namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (vector(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_vector(namount) * vop_FlowNoiseGrad4P (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(vector(flownoise(pp, flowv)) - 0.5); }
    return nval;
}
#line 1118 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
float
vop_dampenFbmFF(float pos, freq, offset; float lacun, amp; int maxoctaves)
{
    float pp = pos * freq + offset;
    float fw = vop_FilterWidth(pp);
    float aa = vop_FilterWidth(pos);
    float plimit = fw/lacun;
    float scale = 1;
    int   octave = 0;
    float fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); while (scale > aa) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); pp *= lacun; scale *= lacun; }
    fbm = amp * fit(fbm, -1.25, 1.25, 0, 1);
    return fbm;
}

float
vop_dampenFbmFV(vector pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector pp = pos * freq + offset;
    float  fw = sqrt(area(pp));
    float  aa = sqrt(area(pos));
    float  plimit = fw/lacun;
    float  scale = 1;
    int    octave = 0;
    float  fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); while (scale > aa) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); pp *= lacun; scale *= lacun; }
    fbm = amp * fit(fbm, -1.25, 1.25, 0, 1);
    return fbm;
}

float
vop_dampenFbmFP(vector4 pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector4 pp = pos * freq + offset;
    float   fw = sqrt(area((vector)pp));
    float   aa = sqrt(area((vector)pos));
    float   plimit = fw/lacun;
    float   scale = 1;
    int     octave = 0;
    float   fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); while (scale > aa) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); pp *= lacun; scale *= lacun; }
    fbm = amp * fit(fbm, -1.25, 1.25, 0, 1);
    return fbm;
}
#line 1178 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
vector
vop_dampenFbmVF(float pos, freq, offset; float lacun, amp; int maxoctaves)
{
    float  pp = pos * freq + offset;
    float  fw = vop_FilterWidth(pp);
    float  aa = vop_FilterWidth(pos);
    float  plimit = fw/lacun;
    float  scale = 1;
    int    octave = 0;
    vector fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); while (scale > aa) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); pp *= lacun; scale *= lacun; }
    fbm = amp * vector(fit(fbm,{-1.25,-1.25,-1.25},{1.25,1.25,1.25},{0,0,0},{1,1,1}));
    return fbm;
}

vector
vop_dampenFbmVV(vector pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector pp = pos * freq + offset;
    float  fw = sqrt(area(pp));
    float  aa = sqrt(area(pos));
    float  plimit = fw/lacun;
    float  scale = 1;
    int    octave = 0;
    vector fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); while (scale > aa) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); pp *= lacun; scale *= lacun; }
    fbm = amp * vector(fit(fbm,{-1.25,-1.25,-1.25},{1.25,1.25,1.25},{0,0,0},{1,1,1}));
    return fbm;
}

vector
vop_dampenFbmVP(vector4 pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector4	pp = pos * freq + offset;
    float fw = sqrt(area((vector)pp));
    float aa = sqrt(area((vector)pos));
    float plimit = fw/lacun;
    float scale = 1;
    int   octave = 0;
    vector	fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); while (scale > aa) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); pp *= lacun; scale *= lacun; }
    fbm = amp * vector(fit(fbm,{-1.25,-1.25,-1.25},{1.25,1.25,1.25},{0,0,0},{1,1,1}));
    return fbm;
}
#line 1249 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
float
vop_perlinNoiseVF(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    float nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((float(noise(pp))) + 0); nval = (float(pow(nval, atten)));
    return nval;
}

vector
vop_perlinNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(noise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(noise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

float
vop_correctperlinNoiseVF(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    float nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 0.5 * scale * ((float(noise(pp))) + -.5); nval = (float(pow(nval, atten)));
    return nval;
}

vector
vop_correctperlinNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 0.5 * scale * ((vector(noise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_correctperlinNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 0.5 * scale * ((vector(noise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

float
vop_simplexNoiseVF(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    float nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += .5 * scale * ((float(xnoise(pp))) + -.5); nval = (float(pow(nval, atten)));
    return nval;
}

vector
vop_simplexNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += .5 * scale * ((vector(xnoise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += .5 * scale * ((vector(xnoise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexCurlNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlxnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexCurlNoise2DVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlxnoise2d(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexCurlNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlxnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinCurlNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinCurlNoise2DVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlnoise2d(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinCurlNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}
#line 1446 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
vector
vop_curlNoiseVV(vector pos, freq, offset, nml;
		string type, geo;
		int turb, bounce;
	    	float amp, rough, atten, distance, radius, h)
{
    vector val = {0,0,0};

    if (type == "exact_pnoise")
    {
	return vop_perlinCurlNoiseVV(pos*freq-offset, turb, amp, rough*2, atten);
    }
    else if (type == "exact_xnoise")
    {
	return vop_simplexCurlNoiseVV(pos*freq-offset, turb, amp, rough*2, atten);
    }


    vector xDiff = pos;		xDiff.x += h;
    vector yDiff = pos;		yDiff.y += h;
    vector zDiff = pos;		zDiff.z += h;


    vector noisevec, xDiffNoise, yDiffNoise, zDiffNoise;
    if( type == "onoise" )
    {
	noisevec = onoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = onoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = onoise(yDiff*freq - offset, turb, rough, atten) * amp;
	zDiffNoise = onoise(zDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "snoise" )
    {
	noisevec = snoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = snoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = snoise(yDiff*freq - offset, turb, rough, atten) * amp;
	zDiffNoise = snoise(zDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "anoise" )
    {
	noisevec = anoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = anoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = anoise(yDiff*freq - offset, turb, rough, atten) * amp;
	zDiffNoise = anoise(zDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if (type == "xnoise" )
    {
	noisevec = vop_simplexNoiseVV(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_simplexNoiseVV(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_simplexNoiseVV(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_simplexNoiseVV(zDiff*freq - offset, turb, amp, rough, atten);
    }
    else
    {
	noisevec = vop_perlinNoiseVV(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_perlinNoiseVV(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_perlinNoiseVV(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_perlinNoiseVV(zDiff*freq - offset, turb, amp, rough, atten);
    }


    float dist, r, d; vector norm = normalize(nml); if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)pos) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; noisevec = (r * noisevec) + ((1-r) * dot(norm, noisevec) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)xDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)xDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; xDiffNoise = (r * xDiffNoise) + ((1-r) * dot(norm, xDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)yDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)yDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; yDiffNoise = (r * yDiffNoise) + ((1-r) * dot(norm, yDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)zDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)zDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; zDiffNoise = (r * zDiffNoise) + ((1-r) * dot(norm, zDiffNoise) * norm);; float dzdy = (yDiffNoise.z - noisevec.z); float dydz = (zDiffNoise.y - noisevec.y); float dxdz = (zDiffNoise.x - noisevec.x); float dzdx = (xDiffNoise.z - noisevec.z); float dydx = (xDiffNoise.y - noisevec.y); float dxdy = (yDiffNoise.x - noisevec.x); val.x = (dzdy - dydz)/h; val.y = (dxdz - dzdx)/h; val.z = (dydx - dxdy)/h; if( bounce ) { vector vn; if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); if( dist < 0 ) { norm = normalize( volumegradient(geo, 0, (vector)pos) ); d = dot(norm, val); if( d < 0 ) { vn = d * norm; val = val - 2*vn; } } } else if( distance < 0 ) { d = dot(norm, val); if( d < 0 ) { vn = d * nml; val = val - 2*vn; } } }

    return val;
}

vector
vop_curlNoiseVP(vector4 pos, freq, offset;
		vector nml;
		string type; string geo;
		int turb, bounce;
		float amp, rough, atten, distance, radius, h)
{
    vector val = {0,0,0};

    if (type == "exact_pnoise")
    {
	return vop_perlinCurlNoiseVP(pos*freq-offset, turb, amp, rough*2, atten);
    }
    else if (type == "exact_xnoise")
    {
	return vop_simplexCurlNoiseVP(pos*freq-offset, turb, amp, rough*2, atten);
    }


    vector4 xDiff = pos;	xDiff.x += h;
    vector4 yDiff = pos;	yDiff.y += h;
    vector4 zDiff = pos;	zDiff.z += h;

    vector noisevec, xDiffNoise, yDiffNoise, zDiffNoise;


    if (type == "xnoise")
    {
	noisevec = vop_simplexNoiseVP(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_simplexNoiseVP(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_simplexNoiseVP(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_simplexNoiseVP(zDiff*freq - offset, turb, amp, rough, atten);
    }
    else
    {
	noisevec = vop_perlinNoiseVP(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_perlinNoiseVP(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_perlinNoiseVP(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_perlinNoiseVP(zDiff*freq - offset, turb, amp, rough, atten);
    }


    float dist, r, d; vector norm = normalize(nml); if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)pos) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; noisevec = (r * noisevec) + ((1-r) * dot(norm, noisevec) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)xDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)xDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; xDiffNoise = (r * xDiffNoise) + ((1-r) * dot(norm, xDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)yDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)yDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; yDiffNoise = (r * yDiffNoise) + ((1-r) * dot(norm, yDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)zDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)zDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; zDiffNoise = (r * zDiffNoise) + ((1-r) * dot(norm, zDiffNoise) * norm);; float dzdy = (yDiffNoise.z - noisevec.z); float dydz = (zDiffNoise.y - noisevec.y); float dxdz = (zDiffNoise.x - noisevec.x); float dzdx = (xDiffNoise.z - noisevec.z); float dydx = (xDiffNoise.y - noisevec.y); float dxdy = (yDiffNoise.x - noisevec.x); val.x = (dzdy - dydz)/h; val.y = (dxdz - dzdx)/h; val.z = (dydx - dxdy)/h; if( bounce ) { vector vn; if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); if( dist < 0 ) { norm = normalize( volumegradient(geo, 0, (vector)pos) ); d = dot(norm, val); if( d < 0 ) { vn = d * norm; val = val - 2*vn; } } } else if( distance < 0 ) { d = dot(norm, val); if( d < 0 ) { vn = d * nml; val = val - 2*vn; } } }

    return val;
}

vector
vop_curlNoise2DVV(vector pos, freq, offset;
		    string type, geo;
		    int turb;
		    float amp, rough, atten, distance, radius, h)
{
    vector val = {0,0,0};

    if (type == "exact_pnoise")
    {
	return vop_perlinCurlNoise2DVV(pos*freq-offset, turb, amp, rough*2, atten);
    }
    else if (type == "exact_xnoise")
    {
	return vop_simplexCurlNoise2DVV(pos*freq-offset, turb, amp, rough*2, atten);
    }


    vector xDiff = pos;		xDiff.x += h;
    vector yDiff = pos;		yDiff.y += h;


    float noise, xDiffNoise, yDiffNoise;
    if( type == "onoise" )
    {
	noise = onoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = onoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = onoise(yDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "snoise" )
    {
	noise = snoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = snoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = snoise(yDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "anoise" )
    {
	noise = anoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = anoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = anoise(yDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if (type == "xnoise")
    {
	noise = vop_simplexNoiseVF(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_simplexNoiseVF(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_simplexNoiseVF(yDiff*freq - offset, turb, amp, rough, atten);
    }
    else
    {
	noise = vop_perlinNoiseVF(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_perlinNoiseVF(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_perlinNoiseVF(yDiff*freq - offset, turb, amp, rough, atten);
    }


    float r;
    if( geo != "" )
    {
	float dist = volumesample(geo, 0, pos);
	r = clamp(dist/radius, -1, 1);
    }
    else
    {
	r = clamp(distance/radius, -1, 1);
    }
    r = ( 15.0 * r - 10.0 * r*r*r + 3.0 * r*r*r*r*r ) / 8.0;
    noise = noise * r;
    xDiffNoise = xDiffNoise * r;
    yDiffNoise = yDiffNoise * r;


    val.x = (yDiffNoise - noise) / h;
    val.y = (noise - xDiffNoise) / h;

    return val;
}

void
vop_displaceAlongNormal(vector pp, nn; float amount, scale, sshear, tshear;
			    int	 for_poly, obj_space, bump_only;
			    vector dP, dN)
{

    if (obj_space)
    {
	float	nscale = length(nn);
	dN = normalize(ntransform("space:object", nn)) * nscale;
	dP = ptransform("space:object", pp);
    }
    else
    {
	dN = nn;
	dP = pp;
    }

    dP += (scale * amount)*dN;
    dP += (sshear * amount) * normalize(Du(dP));
    dP += (tshear * amount) * normalize(Dv(dP));

    if (obj_space)
    {
	dP = ptransform("space:object", "space:current", dP);
    }

    if (for_poly)
	 dN = computenormal(dP, nn, Ng);
    else dN = computenormal(dP);






    if (bump_only)
    {
	dP =  pp;
    }
}





void
vop_displaceAlongVector(vector pp, vec; string space; int mode;
                        float amount, scale, sshear, tshear;
			            vector dP, dN)
{
    dP = pp;
    dN = normalize(N);


    vector ng = Ng;
    vector oP = pp;
    vector oN = vec;
    if (space != "space:current" ) {

        oP = ptransform(space, pp);
        ng = ntransform(space, Ng);

        if ( mode == 0 )
            oN = amount * normalize(ntransform(space, 2*vec-1));
        else if ( mode == 1 )
            oN = ntransform(space, vec);
        else if ( mode == 2 )
            oN = amount * normalize(ntransform(space, N));
    }
    else {
        if ( mode == 0 )
            oN = amount * normalize(2*vec-1);
        else if ( mode == 1 )
            oN = vec;
        else if ( mode == 2 )
            oN = amount * normalize(N);
    }


    oP += scale * oN;
	oN = computenormal(oP, oN, ng);



    if (space != "space:current" ) {
        dP = ptransform(space,"space:current", oP);
        dN = normalize(ntransform(space,"space:current", oN));
    }
    else {
        dP = oP;
        dN = normalize(oN);
    }
}


vector
vop_setcomp(vector in; float fval; int part)
{
    vector out = in;
    setcomp(out, fval, part);
    return out;
}

matrix
vop_setmatcomp(matrix in; float fval; int row, col)
{
    matrix out = in;
    setcomp(out, fval, row, col);
    return out;
}
#line 1757 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
matrix vop_translate(matrix in; vector t) { matrix out = in; translate(out, t); return out; }
matrix vop_translate(matrix in; vector4 t) { matrix out = in; translate(out, t); return out; }
#line 1770 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
matrix vop_rotate(matrix in; float angle; vector axis) { matrix out = in; rotate(out, angle, axis); return out; }
matrix3 vop_rotate(matrix3 in; float angle; vector axis) { matrix3 out = in; rotate(out, angle, axis); return out; }
#line 1784 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
matrix vop_scale(matrix in; vector s) { matrix out = in; scale(out, s); return out; }
matrix3 vop_scale(matrix3 in; vector s) { matrix3 out = in; scale(out, s); return out; }


vector
vop_frompolar(float u, v; float radius)
{
    float	sv = sin(v);
    return set(sv*cos(u), sv*sin(u), cos(v))*radius;
}

vector
vop_topolarXYZ(float x, y, z)
{
    float r = sqrt(x*x+y*y+z*z);
    return set(
	    atan(y, x) % (2* 3.1415926),
	    acos(z/r),
	    r);
}

vector
vop_topolar(vector v)
{
    return vop_topolarXYZ(v.x, v.y, v.z);
}


void
vop_computeTangents(string tstyle;
		    vector nn, uv;
		    vector in_utan, in_vtan;
		    vector out_utan, out_vtan)
{
    if (tstyle == "geo")
    {
	out_utan = normalize(dPds);
	out_vtan = normalize(dPdt);
    }
    else if (tstyle == "world")
    {
	out_vtan = cross(set(0, 0, 1), nn);
	out_vtan = length2(out_vtan) < 1e-6 ? set(1, 0, 0) : normalize(out_vtan);
	out_utan = normalize(cross(nn, out_vtan));
    }
    else if (tstyle == "object")
    {
	out_vtan = cross(ow_vspace(set(0, 0, 1)), nn);
	out_vtan = length2(out_vtan) < 1e-6 ? set(1, 0, 0) : normalize(out_vtan);
	out_utan = normalize(cross(nn, out_vtan));
    }
    else if (tstyle == "uv")
    {
	out_utan = normalize((dPds * Dv(uv.y)) - (dPdt * Du(uv.y)));
	out_vtan = normalize(cross(nn, out_utan));
	out_utan = normalize(cross(nn, out_vtan));
	if (isshadingRHS())
	    out_vtan = -out_vtan;
    }
    else
    {
	out_utan = in_utan;
	out_vtan = in_vtan;
    }
}

void
vop_computeTangentsOld(vector out_tanu, out_tanv;
		       vector nn, uv;
		       vector in_tanu, in_tanv;
		       int tstyle)
{
    string	s_tstyle;
    if (tstyle == 0)
	s_tstyle = "world";
    else if (tstyle == 1)
	s_tstyle = "object";
    else if (tstyle == 2)
    s_tstyle = "uv";
    else
	s_tstyle = "inputs";
    vop_computeTangents(s_tstyle,
	    nn, uv, in_tanu, in_tanv, out_tanu, out_tanv);
}

vector
vop_anisotropic_eval(vector ll; vector nn; vector V;
		vector uv; vector in_tanu; vector in_tanv;
		float urough, vrough; int model; int tstyle)
{
    vector    H;
    vector    clr;
    vector    tanU, tanV;
    float     rz, cos_r, cos_i;

    float     nml_term;
    float     uval, vval, nval;
    float     exponent;

    cos_r = dot(nn, V);
    clr = 0;
    if (cos_r > 0.0)
    {
	vop_computeTangentsOld(tanU, tanV, nn, uv, in_tanu, in_tanv, tstyle);

	cos_i = dot(ll, nn);
	if (cos_i > 0.0)
	{
	    H = normalize(V + ll);
	    uval = dot(tanU, H);
	    vval = dot(tanV, H);
	    nval = dot(nn, H);

	    rz = 0;
	    if (nval > 0)
	    {
		if (model == 0)
		{

		    nml_term = 4.0 * 3.1415926 * urough*vrough;
		    uval /= urough;
		    vval /= vrough;
		    rz = cos_i*exp(-2.*(uval*uval + vval*vval) /
			    (1.0 + nval));
		    rz /= nml_term * sqrt(cos_i*cos_r);
		}
		else
		{

		    exponent = uval*uval/urough + vval*vval/vrough;
		    exponent /= 1.0 - nval*nval;

		    rz = pow(nval, exponent) / (4.0 * dot(V, H));
		}
	    }
	    clr = rz;
	}
    }
    return clr;
}



vector
vop_anisotropic(vector nn; vector V; vector uv; float urough, vrough;
		int model, tstyle)
{
    vector	ll;
    vector	lclr;
    vector	tanu = 0;
    vector	tanv = 0;

    lclr = 0;
    tanu = 0;
    tanv = 0;


    illuminance (P, nn, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	shadow(Cl);
	ll = normalize(L);
	lclr = vop_anisotropic_eval(
		ll, nn, V, uv, tanu, tanv, urough, vrough, model, tstyle);
	lclr *= Cl;
    }
    return lclr;
}

vector
vop_sheen(vector nn, ii; float eta, rough; int facefwd)
{
    vector	R, T;
    float	Kr, Kt, sheen;
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));
    vector	illum = 0;

    fresnel(ii, nn, eta, Kr, Kt, R, T);
    Kr = smooth(0.0, 0.5, Kr);
    illuminance (P, nn, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	vector nL = normalize(L);
	shadow(Cl);
	sheen = specularBRDF(nL, nf, -ii, rough);
	illum += Cl * dot(nL, nf) * (sheen + 0.2);
    }
    return Kr * illum;
}



bsdf
vop_sheen_bsdf(vector nn, ii; float eta, rough; int facefwd)
{
    float	Kr, Kt;
    vector	R, T;
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));
	bsdf    f;

    fresnel(ii, nn, eta, Kr, Kt, R, T);
    Kr = smooth(0.0, 0.5, Kr);
    f = Kr * ((bsdf(diffuse(nf)) * 0.2) +
	       bsdf(diffuse(nf)) * matchvex_specular(nf, 1.0/rough));
    return f;
}

float
vop_specular_eval(string lmodel; vector ll, nf, ii, uv, tanu, tanv;
	     float urough, vrough, sharp; int tstyle)
{
    float	seval = 0;

    if (lmodel == "phong")
    {
	seval = phongBRDF(ll, nf, -ii, 1.0/urough);
    }
    else if (lmodel == "blinn")
    {
	seval = blinnBRDF(ll, nf, -ii, urough);
    }
    else if (lmodel == "glossy")
    {
	float	w = sharp/2.0;

	seval = specularBRDF(ll, nf, -ii, urough);
	if (w > 0)
	    seval = smooth(w, 1-w, seval);
    }
    else if (lmodel == "anisotropic")
    {
	seval = (float)vop_anisotropic_eval(ll, nf, -ii,
		uv, tanu, tanv, urough, vrough, 0, tstyle);
    }
    else if (lmodel == "spec" ||
	     lmodel == "specular")
    {
	seval = specularBRDF(ll, nf, -ii, urough);
    }
    return seval;
}



vector
vop_specular(string lmodel; vector nf, ii, uv;
	     float urough, vrough, sharp; int tstyle)
{
    vector	clr, ll;
    vector	tanu, tanv;

    tanu = 0;
    tanv = 0;

    clr = 0;
    illuminance(P, nf, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	shadow(Cl);
	ll = normalize(L);
	clr += Cl * vop_specular_eval(lmodel, ll, nf, ii, uv, tanu, tanv,
		urough, vrough, sharp, tstyle);
    }

    return clr;
}



bsdf
vop_specular_bsdf(string lmodel; vector nf, ii, uv, tanu, tanv;
	     float urough, vrough, sharp; int tstyle)
{
    bsdf	f;

    if (lmodel == "phong")
    {
	f = bsdf(phong(nf, 1.0/urough));
    }
    else if (lmodel == "blinn")
    {
	f = matchvex_blinn(nf, 1.0/urough);
    }
    else if (lmodel == "glossy")
    {
	f = matchvex_specular(nf, 1.0/urough);
    }
    else if (lmodel == "anisotropic")
    {
	bsdf	aniso_bsdf;
	vector	tanU;
	vector	tanV;

	vop_computeTangentsOld(tanU, tanV, nf, uv, tanu, tanv, tstyle);
	aniso_bsdf = ashikhmin(nf, 2.0/(urough*urough), 2.0/(vrough*vrough),
			       normalize(tanU), normalize(tanV));
	f = (1.0 / (2.0 * 3.1415926 * urough * vrough)) * aniso_bsdf;
    }
    else
    {
	f = matchvex_specular(nf, 1.0/urough);
    }
    return f;
}

float
vop_diffuse_eval(string dmodel; vector ll, nf, ii; float rough)
{
    float	deval = 0;
    if (dmodel == "isotropic")
    {
	deval = 1;
    }
    else if (dmodel == "oren")
    {
	deval = diffuseBRDF(ll, nf, -ii, rough);
    }
    else if (dmodel == "diffuse")
    {
	deval = diffuseBRDF(ll, nf);
    }
    return deval;
}

bsdf
vop_diffuse_bsdf(string dmodel; vector nf, ii; float rough)
{
    bsdf	f;

    if (dmodel == "isotropic")
    {
	f = isotropic();
    }
    else if (dmodel == "oren")
    {
	f = bsdf(diffuse(nf, rough));
    }
    else
    {
	f = bsdf(diffuse(nf));
    }
    return f;
}



vector
vop_lighting(string lmodel;
	     vector nf, ii, uv, amb, diff, spec;
	     float urough, vrough; int tstyle)
{
    vector	clr;

    if (lmodel == "constant")
    {
	clr = diff;
    }
    else if (lmodel == "headlight")
    {
	clr = diff * clamp(dot(nf, -ii), 0, 1);
    }
    else
    {
	float	angle;

	clr = amb * ambient();

	if (lmodel == "isotropic")
	    angle = 3.1415926;
	else
	    angle = 3.1415926/2;

	illuminance(P, nf, angle, (bouncemask("diffuse")|bouncemask("reflect")), "lightexport", "")
	{
	    vector ll = normalize(L);
	    vector lclr = 0;

	    if (diff != {0,0,0})
	    {
		float	deval;
		if (lmodel == "isotropic" ||
		    lmodel == "oren")
		    deval = vop_diffuse_eval(lmodel, ll, nf, ii, urough);
		else
		    deval = vop_diffuse_eval("diffuse", ll, nf, ii, urough);

		lclr += deval * diff;
	    }
	    if (lmodel != "isotropic" &&
		lmodel != "oren" &&
		spec != {0,0,0})
	    {
		vector	tanu = 0;
		vector	tanv = 0;

		float seval = vop_specular_eval(lmodel, ll, nf, ii,
			uv, tanu, tanv, urough, vrough, 0, tstyle);

		lclr += seval * spec;
	    }

	    if (lclr != 0)
	    {
		shadow(Cl);
		clr += lclr * Cl;
	    }
	}
    }
    return clr;
}



bsdf
vop_lighting_bsdf(string lmodel;
	     vector nf, ii, uv, amb, diff, spec;
	     float urough, vrough; int tstyle)
{
    bsdf	f;
    vector	tanu = 0;
    vector	tanv = 0;

    if (lmodel == "constant")
    {
	f = bsdf();
    }
    else if (lmodel == "lambert" ||
	     lmodel == "headlight" ||
	     lmodel == "oren" ||
	     lmodel == "isotropic")
    {
	f = diff * vop_diffuse_bsdf(lmodel, nf, ii, urough);
    }
    else
    {
	tanu = 0;
	tanv = 0;
	f = diff * bsdf(diffuse(nf));
	f += spec * vop_specular_bsdf(lmodel, nf, ii,
		uv, tanu, tanv, urough, vrough, 0, tstyle);
    }
    return f;
}





#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/singlescatter.h"
#line 16 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/singlescatter.h"
float
phase(vector v1, v2; float g)
{
    float costheta = dot(-v1, v2);
	float g2 = g*g;
    return (1.0 - g2) / pow(1.0 + g2 - 2.*g*costheta, 1.5);
}








float
singleScatter(vector in, out, nn; float g, albedo, depth)
{
    float win = abs(dot(in, nn));
    float won = abs(dot(out, nn));
    float offset = phase(out, in, g);

    float scatter = albedo * offset/(win + won);
    scatter *= 1.0 - exp(-(1.0/win + 1.0/won) * depth);

    return scatter;
}

vector
efresnel(vector ii, nn; float eta; float Kr, Kt;)
{
    vector R, T;
    fresnel(ii, nn, eta, Kr, Kt, R, T);
    Kr = smooth(0.0, 0.5, Kr);
    Kt = 1.0 - Kr;
    return normalize(T);
}
#line 2231 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/pcscatter.h"
#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shading.h"
#line 14 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/pcscatter.h"

float vop_hgphase(float g; vector Wi, Wo) {
   float g2=g*g;
        return (1. - g2) / pow(1. + g2 - (2.*g*dot(-Wi,Wo)), 1.5);
}

float vop_hgphaseN(float g; vector Wi, Wo) {
   float g2=g*g;
   float num = g>0 ? -1.+g : 1.+g;
        return pow(num*num,1.5) / pow(1.+g2-(2.*g*dot(-Wi,Wo)),1.5);
}

float vop_ssBounceAtten(vector No,Ni,Li) {
   return 1.0 - ((1.0-dot(No,Ni))* (1.0-dot(No,Li)) / 2.0);
}

float vop_cdfSingle(float y) {
   float yy = clamp(y,0.0,1.0);
   return y<=0. ? 0. : (y>=1. ? 1. : yy*(2.0 + (yy-2.0)*yy*yy));
}


void vop_pcIllum (int handle; string att) {
   vector p, n;
   vector illum;
   int status;
   while (pcunshaded(handle, att)) {
      pcimport(handle, "P", p); p = ow_space(p);
      pcimport(handle, "N", n); n = normalize(ow_nspace(n));
      illum = 0;
      illuminance(p, n, 3.1415926/2, bouncemask("diffuse"), "lightexport", "") {
         shadow(Cl);
         illum += Cl * diffuseBRDF(normalize(L), n);
      }
      status = pcexport(handle, att, illum);
   }
}




void vop_pcIrrad (int handle; string att) {
   vector p, n;
   vector irrad;
   int status;
   while (pcunshaded(handle, att)) {
      pcimport(handle, "P", p); p = ow_space(p);
      pcimport(handle, "N", n); n = normalize(ow_nspace(n));
      irrad = irradiance(p,n);
      status = pcexport(handle, att, irrad);
   }
}


float vop_icdfSingle(float x) {
   float rslt = 0.;
   if(x>=1.) {
      rslt = 1.;
   } else if(x>0.) {
      float a = pow(9. - (9.*x) + (1.73205080756887729353 *
                  sqrt(11.-(6.*x)-(21.*x*x)+(16.*x*x*x))), 0.333333333333333);
      float A = (2.*1.587401051968199*(1.-x)) / (1.442249570307408*a);
      float B = (1.259921049894873*a) / 2.080083823051904;
      float C = sqrt(1.0 + A + B);
      rslt = 0.5 * ( 1.0 + sqrt(2.0 - A - B + (2.0/C)) - C );
   }
   return rslt;
}



vector vop_ssIntegMulti (
   string pcmap;
   vector Rdo;
   float sd;
   float bounce;
   int t_rgb;
   vector pcP;
   vector pcN;
   )
{
   vector Xi,Ni;
   vector Xo = pcP;
   vector No = normalize(pcN);
   vector ld = Rdo*sd;
   float ld1 = max(ld);
   int handle = pcopen(pcmap, "P", Xo, ld1, (int)1e9);
   vop_pcIllum(handle,"illum");
   float r,ptarea;
   vector ssm=0, ptillum=0;
   while (pciterate(handle)) {
      pcimport(handle, "P", Xi);
      pcimport(handle, "N", Ni);
      pcimport(handle, "point.distance", r);
      pcimport(handle, "ptarea", ptarea);
      pcimport(handle, "illum", ptillum);
      Ni = normalize(Ni);
      vector Li = (Xo-Xi)/ld1;
      float kb = vop_ssBounceAtten(No,Ni,Li);
      kb = lerp(1.0,kb,bounce);
      if(kb>0.0 ) {
         if(t_rgb)
         {
            int wave;
            for(wave=0;wave<3;wave++) {
               setcomp( ssm,
                        getcomp(ssm,wave) +
                           kb * getcomp(ptillum,wave) * ptarea *
                           (1-smooth(0,getcomp(ld,wave),r)),
                        wave
                      );
            }
         }
         else
            ssm += kb * ptillum * ptarea * (1-smooth(0,ld1,r));
      }
   }
   pcclose(handle);
   if(!t_rgb) ssm*=Rdo;
   float norm = 3.0*ld1*ld1*3.1415926 / 10.0;
   return ssm / norm;
}


vector vop_ssIntegSingle (
   vector Rd;
   float sd;
   float g;
   float eta;
   int samples;
   float tbias;
   int t_rgb;
   vector PP;
   vector NN;
   vector II;
   )
{
   float Kro, Kto, Kri, Kti;
   vector Xi, Wi, Ni;
   int samp;
   vector Psamp;
   float phase,WiNi,AWiNi,spi,spo,ksss;
   string oname = getobjectname();
   vector Xo = PP;
   vector No = normalize(NN);
   vector Wo = -normalize(II);
   vector lu = Rd*sd;
   float lu1 = max(lu);
   float ieta = 1.0 / eta;
   float ieta2 = ieta * ieta;
   vector To = normalize(refract(-Wo,No,ieta));
   vector Wpo = -To;
   float gg = clamp(g,-0.998,.998);
   if(eta!=1.0) { fresnel(Wpo,-No,ieta,Kro,Kto); }
      else Kto = 1.0;
   vector scatt = 0;
   vector realsamples = 0;
   float hitD = rayhittest(Xo,To*1e6,tbias,"scope",oname);
   float spoMax = hitD<0. ? lu1 : min(hitD,lu1);
   float terr = tbias;
   float sinc = (1.0-2.0*terr)/(float)(samples);
   float ss = terr;
   float ssbase= ss;
   if(t_rgb) {
      vector maxadj = set(
            vop_cdfSingle(clamp(spoMax/lu.x,0.,1.)),
            vop_cdfSingle(clamp(spoMax/lu.y,0.,1.)),
            vop_cdfSingle(clamp(spoMax/lu.z,0.,1.))
         );
      int wave;
      for(wave=0;wave<3;wave++)
      {
         ss=ssbase=terr;
         float luk = getcomp(lu,wave);
         for(samp=0; samp<samples; samp++)
         {
            ss = ssbase+sinc*nrandom();
            spo = spoMax*vop_icdfSingle(ss*getcomp(maxadj,wave));
            ssbase+=sinc;
            Psamp = Xo + (To * spo);
            illuminance(Psamp, No, 3.1415926, bouncemask("diffuse"), "lightexport", "")
            {
               Wi = normalize(L);
               hitD = rayhittest(Psamp,L,Xi,Ni,0.,"scope",oname);
               if(hitD>0.) {
                  setcomp(realsamples,getcomp(realsamples,wave)+1,wave);
                  Ni = normalize(Ni);
                  WiNi = dot(Wi,Ni);
                  AWiNi = abs(WiNi);
                  spi = distance(Psamp,Xi) * AWiNi /
                              sqrt(1.0 - ieta2 * (1.0 - AWiNi*AWiNi));
		  if(spi <= luk && WiNi>0.) {
		      if(eta!=1.0) { fresnel(-Wi,Ni,ieta,Kri,Kti); }
		      else Kti = 1.0;
		      float f = Kti * Kto;
		      phase = vop_hgphaseN(gg,Wi,Wpo);
		      ksss = f * phase * (1-smooth(0,luk,spi));
		      setcomp(scatt,getcomp(scatt,wave) +
			      getcomp(Cl,wave)*WiNi*ksss,
			      wave);
                  }
               }
            }
         }
      }
   } else {
      ss=ssbase=terr;
      float icdfmax = vop_cdfSingle(clamp(spoMax/lu1,0.,1.));
      for(samp=0; samp<samples; samp++)
      {
         ss = ssbase+nrandom()*sinc;
         spo = spoMax*vop_icdfSingle(ss*icdfmax);
         ssbase += sinc;
         Psamp = Xo + (To * spo);
         illuminance(Psamp, No, 3.1415926, bouncemask("diffuse"), "lightexport", "")
         {
            Wi = normalize(L);
            hitD = rayhittest(Psamp,L,Xi,Ni,0.,"scope",oname);
            if(hitD>0.) {
               realsamples += 1;
               Ni = normalize(Ni);
               WiNi = dot(Wi,Ni);
               AWiNi = abs(WiNi);
               spi = distance(Psamp,Xi) * AWiNi /
                           sqrt(1.0 - ieta2 * (1.0 - AWiNi*AWiNi));
               if(spi <= lu1 && WiNi>0.) {
                  if(eta!=1.0) { fresnel(-Wi,Ni,ieta,Kri,Kti); }
                     else Kti = 1.0;
                  float f = Kti * Kto;
                     phase = vop_hgphaseN(gg,Wi,Wpo);
                     ksss = f * phase * (1-smooth(0,lu1,spi));
                  scatt+= Cl * Rd * WiNi * ksss;
               }
            }
         }
      }
   }
      return 2.0 * scatt / realsamples;
}
#line 2232 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"

vector
vop_hairspec(vector nn, V, T; float exp;)
{




    float NdotI = dot(nn, V);
    vector illum = 0;

    illuminance (P, nn, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	vector nL = normalize(L);
	float NdotL = dot(nn, nL);

	float Kajiya = cos(abs(acos(dot(T,nL)) - acos(dot(-T,V))));

	shadow(Cl);
	illum += Cl * NdotL * NdotI * pow(Kajiya, 1.0/exp);
    }
    return illum;
}

vector
vop_simpleSSS(vector nn, ii; float  eta, depth; int facefwd)
{
#line 2270 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
    vector	illum = 0;
    float	Kr, fKr = 1;
    float	Kt = 1;
    float	fKt = 1;
    vector	rayin = efresnel(ii, nn, eta, Kr, Kt);
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));

    illuminance (P, nn, 3.1415926/2, bouncemask("diffuse"), "lightexport", "")
    {
	vector nL = normalize(L);
	vector rayout = efresnel(-nL, nn, eta, fKr, fKt);

	shadow(Cl);
	illum += Cl * dot(nL, nf) * Kt * fKt *
			    (singleScatter(rayin, rayout, nf, .8, .8, depth) +
			     singleScatter(rayin, rayout, nf, .3, .5, depth) +
			     singleScatter(rayin, rayout, nf, 0., .4, depth));
    }
    return illum;
}



bsdf
vop_SSS_bsdf(vector nn, ii; float  eta, depth; int facefwd)
{
    float	Kr = 1;
    float	Kt = 1;
	vector  R, T;
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));
	bsdf    f;

    fresnel(ii, nn, eta, Kr, Kt, R, T);
	Kr = smooth(0, 0.5, Kr);
	Kt = 1 - Kr;


	f = Kt * bsdf(diffuse(nf));
    return f;
}



vector
vop_multiSSS(vector Pin, Nin, Rd; float sd, bounce;
			 string pcmap; int nfp, t_rgb;)
{
   vector Xo = wo_space(Pin);
   vector No = normalize(wo_nspace(Nin));
   vector mapP, mapN, ssm;
   int xxx;
   string ch_ssm = "ssM";
   int handle = pcopen(pcmap, "P", Xo, "N", No, 1e37, nfp);
   while (pcunshaded(handle, ch_ssm)) {
      pcimport(handle, "P", mapP);
      pcimport(handle, "N", mapN);
      ssm = vop_ssIntegMulti(pcmap, Rd, sd, bounce,t_rgb, mapP, mapN);
      xxx = pcexport(handle, ch_ssm, ssm);
   }
   vector bssrdf = vector(pcfilter(handle, ch_ssm));
   pcclose(handle);
   return bssrdf;
}

vector
vop_singleSSS(vector Pin, Nin, Iin, Rd; float sd, g, eta, tbias;
                string pcmap; int nfp, samples, t_rgb;)
{
   vector bssrdf;
   if(pcmap != "")
   {
      vector Xo = wo_space(Pin);
      vector No = normalize(wo_nspace(Nin));
      vector eye = Pin-Iin;
      vector mapP, mapN, ssm;
      int xxx;
      int handle = pcopen(pcmap, "P", Xo, "N", No, 1e37, nfp);
      string ch_ssm = "ssS";
      while (pcunshaded(handle, ch_ssm)) {
         pcimport(handle, "P", mapP);
         pcimport(handle, "N", mapN);
         ssm = vop_ssIntegSingle (Rd,sd, g,eta,samples,tbias,t_rgb,
                              ow_space(mapP),ow_nspace(mapN),mapP-eye);
         xxx = pcexport(handle, ch_ssm, ssm);
      }
      bssrdf = vector(pcfilter(handle, ch_ssm));
      pcclose(handle);
   }
   else
   {
      bssrdf = vop_ssIntegSingle(Rd,sd,g,eta,samples,tbias,t_rgb,Pin,Nin,Iin);
   }
   return bssrdf;
}


vector
vop_trace_environment(string envmap, envobj; vector raydir, bg;)
{
    vector val = 0;
    if (envmap == "")
    {
	val = bg;
    }
    else
    {
	vector	dir = vtransform("space:current", envobj, raydir);
	val = environment(envmap, dir, dir, dir, dir, "lerp", 1);
    }
    return val;
}


vector
vop_trace(vector Nf, nN, PP, dir, atten, bg; string envmap;
	float bias, angle, thresh, jitter, density; string style;
	int samples; float nhit; string envobj;)
{
    nhit = 0;
    vector sum = 0;
    vector raydir = 0;
    float  atten_interp, dist;
    vector hitCf, hitOf, hitP;

    gather( PP, dir,
	    "Cf", hitCf,
	    "Of", hitOf,
	    "P",  hitP,
	    "ray:direction", raydir,
	    "samples", samples,
	    "bias", bias,
	    "angle", angle,
	    "raystyle", style,
	    "rayweight", thresh,
	    "samplebase", jitter,
	    "variancevar", "Cf")
    {

        atten_interp = 1;
        if ((dot(Nf, nN) > 0) && (dot(Nf, raydir) < 0) && (density > 0))
        {
            dist = length(hitP-PP);
            atten_interp = exp(-dist*density);
        }
        sum += lerp(atten, hitCf, atten_interp);

        if (max(hitOf) < 1)
        {
            sum += (set(1,1,1) - hitOf) *
                    vop_trace_environment(envmap, envobj, raydir, bg);
        }

        nhit += 1;
    }
    else
    {

        sum += vop_trace_environment(envmap, envobj, raydir, bg);
        nhit += 1;
    }
    return sum;
}


float
vop_weave(float ss, tt, sfreq, tfreq, width)
{
	float weave = 0;
	if ( sfreq > 0 && tfreq > 0 && width > 0)
	{

		float vv = tt * 0.5;
		float uu = (ss+vv) * sfreq;
		vv = (ss-vv) * tfreq;
		if (((int(floor(uu)) & 1) == 0) ) vv += 0.5;


		float warppulse = sqrt(abs(sin(uu * 3.1415926)));
		warppulse = smooth(1-width, 1, warppulse);

		float weftpulse = sqrt(abs(sin(vv * 3.1415926)));
		weftpulse = smooth(1-width, 1, weftpulse);


		float weft = lerp(0, 1, warppulse);
		weft = lerp(weft, 0, 1-warppulse);

		weft = lerp(0, weft, weftpulse);
		weft = lerp(weft, 0, 1-weftpulse);


		float warp = lerp(0, 1, weftpulse);
		warp = lerp(warp, 0, 1-weftpulse);

		warp = lerp(0, warp, warppulse);
		warp = lerp(warp, 0, 1-warppulse);

		weave = ((((int(floor(uu)) & 1) == 1) && ((int(floor(vv)) & 1) == 0)) ||
						(((int(floor(uu)) & 1) == 0) && ((int(floor(vv)) & 1) == 1))) ?
										weft : warp;
	}
	return weave;
}

vector
vop_toUnitNormal(vector Ni;)
{
    return Ni * 0.5 + 0.5;
}

vector
vop_fromUnitNormal(vector Ni;)
{
    return Ni * 2.0 - 1.0;
}

vector
vop_tangentNormal(vector Ni;
                  vector nn;
                  vector utan;
                  vector vtan;
                  int onspace;
                  int flipX;
                  int flipY;
                  float heightScale;)
{
    vector Nn   = normalize(nn);
    vector Nin  = lerp(Nn, Ni, heightScale);

    vector No;
    No.x = dot(Nin, utan);
    No.y = dot(Nin, vtan);
    No.z = dot(Nin, nn);
    No = normalize(No);

    if (flipX) { No.x = -No.x; }
    if (flipY) { No.y = -No.y; }

    if (onspace == 0) { No = vop_toUnitNormal(No); }

    return No;
}

vector
vop_tangentNormalRemap(vector Ni;
                       vector nn;
                       vector utan;
                       vector vtan;
                       int inspace;
                       int flipX;
                       int flipY;
                       float heightScale;)
{
    vector Nn   = normalize(nn);
    vector Vs	= normalize(utan);
    vector Vt	= normalize(vtan);
    vector Nin  = Ni;

    if (inspace == 0) { Nin = vop_fromUnitNormal(Nin); }

    if (flipX) { Nin.x = -Nin.x; }
    if (flipY) { Nin.y = -Nin.y; }

    matrix M;
    setcomp(M, Vs.x, 0, 0);
    setcomp(M, Vs.y, 0, 1);
    setcomp(M, Vs.z, 0, 2);
    setcomp(M, 0,    0, 3);
    setcomp(M, Vt.x, 1, 0);
    setcomp(M, Vt.y, 1, 1);
    setcomp(M, Vt.z, 1, 2);
    setcomp(M, 0,    1, 3);
    setcomp(M, Nn.x, 2, 0);
    setcomp(M, Nn.y, 2, 1);
    setcomp(M, Nn.z, 2, 2);
    setcomp(M, 0,    2, 3);
    setcomp(M, 0,    3, 0);
    setcomp(M, 0,    3, 1);
    setcomp(M, 0,    3, 2);
    setcomp(M, 1,    3, 3);

    vector No = normalize(ntransform(Nin, M));

    No = lerp(Nn, No, heightScale);

    return No;
}

vector
vop_bumpToNormalMap(string map;
                    int onspace;
                    int flipX;
                    int flipY;
                    float heightScale;
                    vector uv;)
{
    int xres = 0;
    teximport(map, "texture:xres", xres);
    int yres = 0;
    teximport(map, "texture:yres", yres);
    float dx = 1.0 / max(xres, yres);

    vector v00 = texture(map, uv.x-dx, uv.y-dx);
    vector v01 = texture(map, uv.x-dx, uv.y   );
    vector v02 = texture(map, uv.x-dx, uv.y+dx);
    vector v10 = texture(map, uv.x,    uv.y-dx);
    vector v12 = texture(map, uv.x,    uv.y+dx);
    vector v20 = texture(map, uv.x+dx, uv.y-dx);
    vector v21 = texture(map, uv.x+dx, uv.y   );
    vector v22 = texture(map, uv.x+dx, uv.y+dx);

    float f00 = luminance(v00);
    float f01 = luminance(v01);
    float f02 = luminance(v02);
    float f10 = luminance(v10);
    float f12 = luminance(v12);
    float f20 = luminance(v20);
    float f21 = luminance(v21);
    float f22 = luminance(v22);

    vector No;
    No.x = f20 + 2*f21 + f22 -f00 - 2*f01 - f02;
    No.y = f02 + 2*f12 + f22 -f00 - 2*f10 - f20;
    No.z = 1.0 / heightScale;
    if (flipX) { No.x = -No.x; }
    if (flipY) { No.y = -No.y; }
    No = normalize(No);

    if (onspace == 0) { No = vop_toUnitNormal(No); }

    return No;
}


void
vop_curvature(vector p;
              vector n;
              int mode;
              int space;
              int smooth;
              float tolerance;
              float convexscale;
              float convexbias;
              float concavescale;
              float concavebias;
              float biasmap;
              float Ko;)
{
    float xa = area(P);

    vector dPdu, dPdv;
    getderiv(p, "P", 0, s, t, dPdu, dPdv, "smooth", smooth);
    dPdu /= xa;
    dPdv /= xa;

    vector dNdu, dNdv;
    getderiv(n, "N", 0, s, t, dNdu, dNdv, "smooth", smooth);
    dNdu /= xa;
    dNdv /= xa;

    float a00 = dot(dPdu, dPdu);
    float a01 = dot(dPdu, dPdv);
    float a11 = dot(dPdv, dPdv);

    float b00 = -dot(dNdu, dPdu);
    float b01 = -(dot(dNdu, dPdv) + dot(dNdv, dPdu)) / 2;
    float b11 = -dot(dNdv, dPdv);

    float a = a00*a11 - a01*a01;
    float b = b00*b11 - b01*b01;
    float aa = max(abs(a), tolerance) * sign(a);

    float cn00 = a11 / aa;
    float cn01 = -a01 / aa;
    float cn11 = a00 / aa;

    float K = b / aa;
    float H = ((cn00*b00 + cn11*b11) / 2) + (cn01*b01);

    float Q = H*H - 4*K;
    float QQ = max(Q, 0);
    float SQ = sqrt(QQ);

    float p0 = (H + SQ) / 2;
    float p1 = (H - SQ) / 2;

    Ko = 0;

    if (mode == 0)
    {
        Ko = K;
    }
    else if (mode == 1)
    {
        Ko = -H;
    }

    float biasr = clamp(biasmap, 0, 1) - 0.5;
    if (Ko >  0) { Ko *= convexscale;  Ko =  vop_bias( Ko, clamp(convexbias  + biasr, 0, 1)); }
    if (Ko <= 0) { Ko *= concavescale; Ko = -vop_bias(-Ko, clamp(concavebias + biasr, 0, 1)); }

    if (space == 0)
    {
        Ko = fit(Ko, -1, 1, 0, 1);
    }
}
#line 174 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 176 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 177 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
#line 179 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 181 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 182 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 184 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet2(int check; vector surface)
{
    if(check!=0){
    surface=surface;
    }
    else{
    surface=set(1,1,1);
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 198 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet14(int val1; string val2)
{
    if(val2 !=""){
    val1=1;
    }
    else{
    val1=0;
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 212 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet13(int val1; string val2)
{
    if(val2 !=""){
    val1=1;
    }
    else{
    val1=0;
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 226 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet15(int val1; string val2)
{
    if(val2 !=""){
    val1=1;
    }
    else{
    val1=0;
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 240 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 241 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 243 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 244 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 246 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 247 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 249 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 250 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 252 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 253 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 255 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 256 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 258 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 259 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 261 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 262 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 264 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 265 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 267 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 268 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 270 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 271 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 273 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_displacetexture1_strlen1_snippet1(string str; int resultcharacter)
{
    resultcharacter = strlen(str);

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 282 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 283 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 285 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_displacetexture1_displace2_swizzle(string order; vector vec)
{
    if(order == "xzy")
        vec = swizzle(vec, 0, 2, 1);

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 295 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
#line 297 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 299 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 301 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 302 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 304 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 306 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 307 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
#line 309 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 311 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 312 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 314 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 315 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 317 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 319 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 320 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 322 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet5(int check; vector gloss)
{
    if(check!=0){
    gloss=gloss;
    }
    else{
    gloss=set(1,1,1);
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 336 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 337 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shading.h"
#line 339 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 341 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet3(int check; bsdf surface; bsdf reflect)
{
    if(check!=0){
    surface=surface+reflect;
    }
    else{
    surface=reflect;
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 355 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 356 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 358 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet1(int check; bsdf surface; bsdf trans)
{
    if(check>0){
    surface=surface+trans;
    }
    else{
    surface=surface;
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 372 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 373 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/pbr.h"
#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 23 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/pbr.h"
#line 130 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/pbr.h"
vector
pbr_get_pixel(vector p;)
{
    vector res;
    renderstate("renderer:resolution", res);

    vector pr = ptransform("space:current", "space:ndc", p);
    pr.x *= res.x;
    pr.y *= res.y;
    pr.x = floor(pr.x);
    pr.y = floor(pr.y);
    pr.z = 0;

    return pr;
}






vector
pbr_sample_disc(float u;
                float v;
                float radius;
                float radiuspower)
{
    float r = sqrt(pow(u, radiuspower)) * radius;
    float theta = 6.2831852 * v;
    vector x;
    x.x = r * cos(theta);
    x.y = r * sin(theta);
    x.z = 0;

    return x;
}

void
pbr_increment_level(
	int pathstate;
	int reflectlevel;
	int refractlevel;
	int diffuselevel;
        int ssslevel;
	int volumelevel;
	string raystyle)
{
    pathstate &= bouncemask("all");
    if (pathstate & bouncemask("alldiffuse"))
    {
	diffuselevel++;
	raystyle = "diffuse";
    }
    else if (pathstate & bouncemask("allsss"))
    {
        ssslevel++;
        raystyle = "sss";
    }
    else if (pathstate & ((bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss"))) & ~bouncemask("allrefract")))
    {
	reflectlevel++;
	raystyle = "reflect";
    }
    else if (pathstate & bouncemask("allrefract"))
    {
	refractlevel++;
	raystyle = "refract";
    }
    else if (pathstate & bouncemask("allvolume"))
    {
	volumelevel++;
	raystyle = "diffuse";
    }
}

int
pbr_findlight(int lights[]; int lid; int end)
{
    for (int i = 0; i < end; i++)
	if (lights[i] == lid)
	    return i;
    return -1;
}

float
pbr_filterangle(float pdf; float amount)
{
    return amount / sqrt(pdf*16 + 4);
}

void
pbr_variance_settings(string prefix; int ismicropoly;
              int minsamples; int maxsamples;
              float threshold;
              float diffusequality;
              float sssquality;
              float refractionquality;
              float reflectionquality;)
{
    minsamples = maxsamples = 1;
    renderstate(prefix + "minraysamples", minsamples);
    renderstate(prefix + "maxraysamples", maxsamples);

    threshold = 0;
    if (maxsamples > minsamples)
    {
        renderstate(prefix + "variance", threshold);
        renderstate(prefix + "diffusequality", diffusequality);
        renderstate(prefix + "sssquality", sssquality);
        renderstate(prefix + "refractionquality", refractionquality);
        renderstate(prefix + "reflectionquality", reflectionquality);
    }

    if (!ismicropoly)
    {
        vector	vsamples = 0;
        renderstate("renderer:samples", vsamples);
        float	psamples = vsamples.x * vsamples.y;
        threshold *= sqrt(psamples);
    }
}

void
pbr_indirect_variance_settings(string prefix; int ismicropoly;
		      int minsamples; int maxsamples;
                      float threshold;
                      float diffusequality;
                      float sssquality;
                      float refractionquality;
                      float reflectionquality;
                      float volumequality;)
{
    minsamples = maxsamples = 1;
    int decoupleindirect = 0;
    renderstate(prefix + "decoupleindirect", decoupleindirect);
    if (decoupleindirect)
    {
        renderstate(prefix + "minindirectraysamples", minsamples);
        renderstate(prefix + "maxindirectraysamples", maxsamples);
    }
    else
    {
        renderstate(prefix + "minraysamples", minsamples);
        renderstate(prefix + "maxraysamples", maxsamples);
    }

    threshold = 0;
    float globalquality = 1.0;
    diffusequality = 1.0;
    sssquality = 1.0;
    refractionquality = 1.0;
    reflectionquality = 1.0;
    if (maxsamples > minsamples)
    {
        if (decoupleindirect)
            renderstate(prefix + "indirectvariance", threshold);
        else
            renderstate(prefix + "variance", threshold);

        renderstate(prefix + "globalquality", globalquality);
        renderstate(prefix + "diffusequality", diffusequality);
        renderstate(prefix + "sssquality", sssquality);
        renderstate(prefix + "refractionquality", refractionquality);
        renderstate(prefix + "reflectionquality", reflectionquality);
        renderstate(prefix + "volumequality", volumequality);

        diffusequality *= globalquality;
        sssquality *= globalquality;
        refractionquality *= globalquality;
        reflectionquality *= globalquality;
        volumequality *= globalquality;
    }

    if (!ismicropoly)
    {
	vector	vsamples = 0;
	renderstate("renderer:samples", vsamples);
	float	psamples = vsamples.x * vsamples.y;
	threshold *= sqrt(psamples);
    }
}





struct pbr_grid_f
{
    void resize(int resolution_;)
    {
        resolution = max(1, resolution_);
        dx = 1.0 / resolution;
        resize(buf, resolution*resolution);
    }

    void assign(float value;)
    {
        for (int i = 0; i < resolution*resolution; i++)
        {
            buf[i] = value;
        }
    }

    void addSample(float sx;
                   float sy;
                   float value;)
    {
        int ix = floor(sx * resolution);
        int iy = floor(sy * resolution);
        buf[iy*resolution + ix] += value;
    }

    void scale(float x;)
    {
        for (int i = 0; i < resolution*resolution; i++)
        {
            buf[i] *= x;
        }
    }

    float sum()
    {
        float x = 0;

        for (int i = 0; i < resolution*resolution; i++)
        {
            x += buf[i];
        }

        return x;
    }

    float average()
    {
        float x = this->sum();

        return x / (resolution*resolution);
    }

    void range(float vmin, vmax)
    {
        vmin = 1e6;
        vmax = -1e6;

        for (int i = 0; i < resolution*resolution; i++)
        {
            vmin = min(vmin, buf[i]);
            vmax = max(vmax, buf[i]);
        }
    }

    float variance()
    {
        float vmin = 1e6;
        float vmax = -1e6;
        this->range(vmin, vmax);

        return vmax - vmin;
    }

    void write(string filename;)
    {
        int i = 0;

        for (int y = 0; y < resolution; y++)
        {
            for (int x = 0; x < resolution; x++)
            {
                vector Pr;
                Pr.x = x;
                Pr.y = y;
                Pr.z = 0;

                vector Ce;
                Ce.x = buf[i];
                Ce.y = buf[i];
                Ce.z = buf[i];

                pcwrite(filename, "P", Pr, "Ce", Ce);

                i++;
            }
        }
    }

    int resolution;
    float dx;
    float buf[];
}





struct pbr_varianceaa
{
    void reset()
    {
        var = { 0, 0, 0, 0 };
        prevlum = { 0, 0, 0, 0 };
        done = 0;
        nsamples = { 0, 0, 0, 0 };
    }

    int numSamples()
    {
        return (nsamples[0] + nsamples[1] + nsamples[2] + nsamples[3]);
    }

    int atEnd()
    {
        return done;
    }

    void advance(int pathstate; vector value;
         int minsamples; int maxsamples;
         string colorspace;
         float threshold;
         float diffusequality;
         float sssquality;
         float refractionquality;
         float reflectionquality;)
    {
        int psi = ( pathstate & (bouncemask("alldiffuse") | bouncemask("allvolume")) ) ? 0 : ( pathstate & bouncemask("allsss") ) ? 1 : ( pathstate & bouncemask("allrefract") ) ? 2 : ( pathstate & bouncemask("all") ) ? 3 : 0;

        int wmaxsamples[] = {0, 0, 0, 0};
        wmaxsamples[0] = floor(maxsamples * diffusequality);
        wmaxsamples[1] = floor(maxsamples * sssquality);
        wmaxsamples[2] = floor(maxsamples * refractionquality);
        wmaxsamples[3] = floor(maxsamples * reflectionquality);

        if ((wmaxsamples[psi] > minsamples) && (nsamples[psi]+1) < wmaxsamples[psi])
        {
            float lum = luminance(value) / (nsamples[psi]+1);
            if (colorspace == "gamma")
            lum = sqrt(lum);

            int		samplesize;
            float	mean;
            float	newvar = variance(lum - prevlum[psi], mean, samplesize);

            var[psi] = (var[psi]*nsamples[psi] + newvar) / (nsamples[psi]+1);
            prevlum[psi] = lum;

            done = (nsamples[psi]+1) >= minsamples
                    && var[0] < (threshold*threshold * 1.0 / diffusequality)
                    && var[1] < (threshold*threshold * 1.0 / sssquality)
                    && var[2] < (threshold*threshold * 1.0 / refractionquality)
                    && var[3] < (threshold*threshold * 1.0 / reflectionquality);
        }
        else
        {
            done = (nsamples[psi]+1) >= minsamples;
        }

        nsamples[psi]++;
    }

    float   var[] = { 0, 0, 0, 0 };
    float   prevlum[] = { 0, 0, 0, 0 };
    int     done;
    int     nsamples[] = { 0, 0, 0, 0 };
}

pbr_varianceaa variance_start()
{
    return pbr_varianceaa();
}



struct pbr_lighting_parms {
    int		doshadow;
}






void
pbr_bounce_mask(int direct_bounces; int indirect_bounces;
		int shadow_bounces; int background_bounces;
		int direct_mask; int indirect_mask;
		string pathtype; int pathstate; int hitBounces;
		int reflectlevel; int reflectlimit;
		int refractlevel; int refractlimit;
		int diffuselevel; int diffuselimit;
                int ssslevel; int ssslimit;
		int volumelevel; int volumelimit;
		string raylimiteval; int raylimitmask;)
{

    if (pathtype == "diffuse" ||
	pathtype == "specular")
    {
        if (pathstate & (bouncemask("alldiffuse") | bouncemask("allvolume") | bouncemask("allsss")))
	{




            indirect_bounces = bouncemask("alldiffuse") | bouncemask("allvolume") | bouncemask("allsss");
            direct_bounces = bouncemask("alldiffuse") | bouncemask("allvolume") | bouncemask("allsss");
	}
	else
	{





	    indirect_bounces = bouncemask("all");
	    direct_bounces = bouncemask("all");
	}
    }
    else
    {
	indirect_bounces = bouncemask("all");
	direct_bounces = bouncemask("all");
    }


    direct_bounces &= direct_mask;
    indirect_bounces &= indirect_mask;


    raylimitmask = 0;
    if (reflectlevel >= reflectlimit)
        raylimitmask |= ((bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss"))) & ~bouncemask("allrefract"));
    if (refractlevel >= refractlimit)
        raylimitmask |= bouncemask("allrefract");
    if (diffuselevel >= diffuselimit)
        raylimitmask |= bouncemask("alldiffuse");
    if (ssslevel >= ssslimit)
    {
        raylimitmask |= bouncemask("allsss");

    }
    if (volumelevel >= volumelimit)
        raylimitmask |= bouncemask("allvolume");

    background_bounces = 0;
    shadow_bounces = direct_bounces;
    if (raylimiteval == "direct")
    {
        indirect_bounces &= ~(raylimitmask & ~(bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss"))));
        raylimitmask &= (bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss")));
        shadow_bounces &= ~raylimitmask;
        background_bounces = raylimitmask;
    }
    else
    {
        indirect_bounces &= ~raylimitmask;
    }


    direct_bounces &= hitBounces;
    indirect_bounces &= hitBounces;
}

float
pbr_shadowmattecomp(float lit; float shad)
{
    return shad > 1e-6 ? max(1.0 - lit/shad, 0.0) : 0.0;
}

vector
pbr_shadowmatte(vector lit; vector shad)
{
    return (vector)pbr_shadowmattecomp(max(lit), max(shad));
}



float
pbr_clampCf(vector clr; float colorlimit)
{
    float	kscale = 1;
    float	lum = luminance(clr);
    if (colorlimit >= 0 && lum > colorlimit)
	kscale = colorlimit/lum;
    return kscale;
}

struct pbr_sss_trace_cache
{
    int seed = 0;
    vector exitN[];
    vector exitP[];
    vector throughput[];
};




int
get_lpe_labels(string event; string scatter; int bounce)
{
    if (bounce & bouncemask("alldiffuse"))
    {
	event = "R";
	scatter = "D";
    }
    else if (bounce & ((bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss"))) & ~bouncemask("allrefract")))
    {
	event = "R";
	scatter = "G";
    }
    else if (bounce & bouncemask("allrefract"))
    {
	event = "T";
	scatter = "G";
    }
    else if (bounce & bouncemask("allvolume"))
    {
	event = "V";
	scatter = "x";
    }
    else if (bounce & bouncemask("allsss"))
    {
	event = "T";
	scatter = "D";
    }
    else
    {
	return 0;
    }
    return 1;
}
#line 374 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 376 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 377 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/shaderlayer.h"
#line 379 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 381 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 382 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 384 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_snippet8(int check; float val1; float val2)
{
    if(check!=0){
    val1=val1;
    }
    else{
    val1=val2;
    }

}



#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 398 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 399 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 401 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 402 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voptype.h"
#line 404 "/mat/megascans_shader_simple1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/voplib.h"
#line 405 "/mat/megascans_shader_simple1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs18.5.499/houdini/vex/include/math.h"
#line 407 "/mat/megascans_shader_simple1/SurfaceVexCode"
void
_mat_megascans_shader_simple1_asset_bake_exports1_add_layer_exports(ShaderLayer layer; vector export_diffcolor; float export_rough; vector export_ior; float export_metallness; vector export_speccolor; vector export_translucency; vector export_sss; vector export_emission; float export_mask; float export_fuzz; vector export_uv; vector export_dispcolor; vector export_normal; vector export_bump; vector export_ao; vector export_opacity)
{
    int bake_layerexport = 0;
    renderstate("global:bake_layerexport", bake_layerexport);

    if(!bake_layerexport)
        return;


    int numf = len(layer.exports.names_f);
    resize(layer.exports.names_f, numf + 4);
    layer.exports.names_f[numf] = "export_rough";
    layer.exports.values_f[numf++] = export_rough;
    layer.exports.names_f[numf] = "export_metalness";
    layer.exports.values_f[numf++] = export_metallness;
    layer.exports.names_f[numf] = "export_mask";
    layer.exports.values_f[numf++] = export_mask;
    layer.exports.names_f[numf] = "export_fuzz";
    layer.exports.values_f[numf++] = export_fuzz;



    int numv = len(layer.exports.names_v);
    resize(layer.exports.names_v, numv + 12);
    layer.exports.names_v[numv] = "export_diffcolor";
    layer.exports.values_v[numv++] = export_diffcolor;
    layer.exports.names_v[numv] = "export_ao";
    layer.exports.values_v[numv++] = export_ao;
    layer.exports.names_v[numv] = "export_ior";
    layer.exports.values_v[numv++] = export_ior;
    layer.exports.names_v[numv] = "export_speccolor";
    layer.exports.values_v[numv++] = export_speccolor;
    layer.exports.names_v[numv] = "export_translucency";
    layer.exports.values_v[numv++] = export_translucency;
    layer.exports.names_v[numv] = "export_sss";
    layer.exports.values_v[numv++] = export_sss;
    layer.exports.names_v[numv] = "export_emission";
    layer.exports.values_v[numv++] = export_emission;
    layer.exports.names_v[numv] = "export_uv";
    layer.exports.values_v[numv++] = export_uv;
    layer.exports.names_v[numv] = "export_dispcolor";
    layer.exports.values_v[numv++] = export_dispcolor;
    layer.exports.names_v[numv] = "export_normal";
    layer.exports.values_v[numv++] = export_normal;
    layer.exports.names_v[numv] = "export_bump";
    layer.exports.values_v[numv++] = export_bump;
    layer.exports.names_v[numv] = "export_opacity";
    layer.exports.values_v[numv++] = export_opacity;

}

surface
mat_megascans_shader_simple1(vector uv = { 0, 0, 0 };
	vector2 st = { 0, 0 };
	string ms_diffuse = "";
	string ms_ior = "";
	string ms_rough = "";
	float ms_rscale = 0;
	string ms_ao = "";
	string ms_normal = "";
	string ms_reflect = "";
	string ms_displace = "";
	float ms_dscale = 0;
	string ms_bump = "";
	string ao_texture = "";
	string albedo_texture = "";
	string ior_texture = "";
	string rough_texture = "";
	float rough = 1;
	string reflect_texture = "";
	export ShaderLayer layer = {};
	string bump_texture = "";
	string normal_texture = "";
	string disp_texture = "";
	float dispTex_scale = 1;
	string ms_trans = "";
	string trans_texture = "";
	string ms_opac = "";
	string opaccolor_texture = "";
	export float ms_occlusion = 0;
	float ms_reflectscale = 0;
	float reflect_scale = 1;
	float Shift = 0;
	float Saturation = 1;
	float Value = 1;
	vector Bias = { 0.5, 0.5, 0.5 };
	vector Gain = { 0.5, 0.5, 0.5 };
	float Gamma = 1;
	int ms_opacval = 0;
	int use_opacity = 0;
	export float layer_mask = 0;
	float addative_displace = 0;
	float dispoffset = 0.5;
	export vector export_dispcolor = { 0, 0, 0 };
	export vector export_normal = { 0, 0, 0 };
	export vector export_ao = { 0, 0, 0 };
	export vector export_ior = { 0, 0, 0 };
	export vector export_speccolor = { 0, 0, 0 };
	export vector export_translucency = { 0, 0, 0 };
	export vector export_sss = { 0, 0, 0 };
	export vector export_emission = { 0, 0, 0 };
	export float export_rough = 0;
	export float export_metallness = 0;
	export float export_mask = 0;
	export float export_fuzz = 0;
	export vector export_uv = { 0, 0, 0 };
	export vector export_bump = { 0, 0, 0 };
	export vector export_opacity = { 0, 0, 0 };
	export vector Oc = { 0, 0, 0 };
	export vector Cv = { 0, 0, 0 };
	export vector Th = { 0, 0, 0 };
	export vector Ab = { 0, 0, 0 };
	export vector Cu = { 0, 0, 0 };
	export vector Vd = { 0, 0, 0 };
	export vector Nt = { 0, 0, 0 };
	export vector Ds = { 0, 0, 0 };
	export vector Vdt = { 0, 0, 0 };
	float curvatureConvex = 0;
	float curvatureConcave = 0;
	export vector export_diffcolor = { 0, 0, 0 };
	string ms_metal = "";
	string metallic_texture = "";
	float normal_mult = 1;
	int dmultopacity = 0;
	int simplify_bsdf = 0)
{
    int	bound_ms_opacval;
    int	bound_ms_opac;
    int	bound_uv;
    int	bound_st;
    int	bound_uv1;
    int	bound_st1;
    int	bound_ms_trans;
    int	bound_ms_diffuse;
    int	bound_ms_ao;
    int	bound_uv2;
    int	bound_st2;
    int	bound_uv3;
    int	bound_st3;
    int	bound_ms_normal;
    int	bound_uv4;
    int	bound_st4;
    int	bound_ms_metal;
    int	bound_ms_rough;
    int	bound_uv5;
    int	bound_st5;
    int	bound_ms_ior;
    int	bound_uv6;
    int	bound_st6;
    int	bound_ms_reflect;
    int	bound_uv7;
    int	bound_st7;
    int	bound_uv8;
    int	bound_st8;
    int	bound_ms_reflectscale;
    int	bound_uv9;
    int	bound_st9;
    int	bound_addative_displace;
    int	bound_ms_displace;
    int	bound_uv10;
    int	bound_st10;
    int	bound_ms_dscale;
    int	bound_uv11;
    int	bound_st11;
    int	bound_ms_bump;
    int	bound_uv12;
    int	bound_st12;
    int	bound_uv13;
    int	bound_st13;
    int	bool1;
    int	val;
    int	found;
    int	result;
    int	result1;
    int	result2;
    int	check;
    int	bool2;
    string	val1;
    int	found1;
    string	result3;
    string	result4;
    string	result5;
    int	outval1;
    string	outval2;
    int	bool3;
    vector	uv2;
    vector	output1;
    vector	result6;
    vector	result7;
    vector	result8;
    float	fval1;
    float	fval2;
    float	fval3;
    int	bool4;
    vector	uv4;
    vector	output11;
    vector	result9;
    vector	result10;
    vector	result11;
    float	fval11;
    float	fval21;
    float	fval31;
    vector	result12;
    vector	_uv1;
    vector	clr1;
    vector	surface;
    int	outcheck;
    vector	outsurface;
    vector	result13;
    int	bool5;
    string	val2;
    int	found2;
    string	result14;
    string	result15;
    string	result16;
    int	bool6;
    int	check1;
    int	check2;
    int	outval11;
    string	outval21;
    string	val3;
    int	found3;
    int	bool7;
    string	result17;
    string	result18;
    string	result19;
    int	outval12;
    string	outval22;
    int	check3;
    int	outval13;
    string	outval23;
    string	val4;
    int	found4;
    int	bool8;
    string	result20;
    string	result21;
    string	result22;
    int	bool9;
    int	val5;
    int	found5;
    int	bool10;
    vector	uv6;
    vector	output12;
    vector	result23;
    vector	result24;
    vector	result25;
    float	fval12;
    float	fval22;
    float	fval32;
    vector	result26;
    vector	_uv3;
    vector	clr3;
    vector	to;
    vector	result27;
    vector	result28;
    float	rand;
    float	shift;
    int	added;
    vector	rand1;
    vector	shift1;
    vector	hsv;
    float	fval13;
    float	fval23;
    float	fval33;
    float	fraction;
    float	sum;
    float	fraction1;
    float	product;
    float	product1;
    vector	vec;
    vector	rgb;
    vector	bias;
    vector	gain;
    float	inverse;
    vector	pow;
    vector	result29;
    vector	diff;
    int	bool11;
    vector	uv8;
    vector	output13;
    vector	result30;
    vector	result31;
    vector	result32;
    float	fval14;
    float	fval24;
    float	fval34;
    vector	result33;
    vector	_uv5;
    vector	clr5;
    float	lum;
    float	shift2;
    vector	product2;
    vector	result34;
    vector	hsv1;
    float	fval15;
    float	fval25;
    float	fval35;
    float	fraction2;
    float	sum1;
    float	fraction3;
    float	product3;
    float	product4;
    vector	vec1;
    vector	rgb1;
    vector	bias1;
    vector	gain1;
    float	inverse1;
    vector	pow1;
    vector	result35;
    vector	nvec;
    int	bool12;
    string	val6;
    int	found6;
    string	result36;
    string	result37;
    string	result38;
    int	bool13;
    vector	uv10;
    vector	output14;
    vector	result39;
    vector	result40;
    vector	result41;
    float	fval16;
    float	fval26;
    float	fval36;
    vector	result42;
    float	fval17;
    float	fval27;
    float	fval37;
    vector	clr6;
    int	Value2;
    string	outstr;
    int	outresultcharacter;
    int	bool14;
    float	product5;
    int	bool15;
    int	bool16;
    int	scaled;
    int	bool17;
    int	scaled1;
    int	sum2;
    vector	result43;
    vector	result44;
    vector	nvec1;
    float	lum1;
    float	fval18;
    float	fval28;
    float	fval38;
    float	result45;
    float	sum3;
    vector	dispP;
    vector	dispN;
    vector	product6;
    string	outorder;
    vector	outvec;
    vector	result46;
    int	bool18;
    int	bool19;
    int	connected;
    vector	result47;
    vector	nvec2;
    vector4	quat;
    string	tstyle;
    vector	in_utan;
    vector	in_vtan;
    vector	nml;
    vector	result48;
    vector	uv11;
    vector	utan;
    vector	vtan;
    vector	result49;
    vector	result50;
    vector	result51;
    vector	result52;
    float	fval19;
    float	fval29;
    float	fval39;
    float	fval110;
    float	fval210;
    float	fval310;
    float	fval111;
    float	fval211;
    float	fval311;
    matrix3	matx;
    matrix	xform;
    matrix3	m3;
    matrix3	result53;
    matrix	xform1;
    matrix3	m31;
    matrix3	result54;
    vector	product7;
    vector	sum4;
    vector	result55;
    vector	dispP1;
    vector	dispN1;
    vector	Ns;
    vector	Nf;
    vector	product8;
    vector	nvec3;
    float	dotprod;
    float	trig;
    vector	crossprod;
    vector	nvec4;
    vector4	quat1;
    vector4	blend;
    vector	result56;
    vector	newN;
    vector	result57;
    vector	Value3;
    vector	diff1;
    vector	result58;
    float	Value4;
    float	product9;
    float	len;
    float	result59;
    vector	nvec5;
    ShaderLayer	layer1;
    bsdf	f;
    int	bool20;
    string	val7;
    int	found7;
    int	bool21;
    string	result60;
    string	result61;
    string	result62;
    int	bool22;
    int	bool23;
    string	val8;
    int	found8;
    int	bool24;
    string	result63;
    string	result64;
    string	result65;
    int	bool25;
    vector	uv13;
    vector	output15;
    vector	result66;
    vector	result67;
    vector	result68;
    float	fval112;
    float	fval212;
    float	fval312;
    vector	result69;
    vector	_uv10;
    vector	clr8;
    float	lum2;
    float	val9;
    int	found9;
    int	bool26;
    float	result70;
    float	result71;
    int	bool27;
    float	result72;
    float	product10;
    float	clamp;
    int	bool28;
    string	val10;
    int	found10;
    int	bool29;
    string	result73;
    string	result74;
    string	result75;
    int	bool30;
    vector	uv15;
    vector	output16;
    vector	result76;
    vector	result77;
    vector	result78;
    float	fval113;
    float	fval213;
    float	fval313;
    vector	result79;
    vector	_uv12;
    vector	clr10;
    float	lum3;
    bsdf	f1;
    int	bool31;
    string	val11;
    int	found11;
    int	bool32;
    string	result80;
    string	result81;
    string	result82;
    int	bool33;
    int	bool34;
    vector	uv17;
    vector	output17;
    vector	result83;
    vector	result84;
    vector	result85;
    float	fval114;
    float	fval214;
    float	fval314;
    vector	result86;
    vector	_uv14;
    vector	clr12;
    vector	clamp1;
    int	outcheck1;
    vector	outgloss;
    vector	clamp2;
    bsdf	product11;
    int	bool35;
    vector	uv19;
    vector	output18;
    vector	result87;
    vector	result88;
    vector	result89;
    float	fval115;
    float	fval215;
    float	fval315;
    vector	result90;
    vector	_uv16;
    vector	clr14;
    bsdf	f2;
    bsdf	sum5;
    bsdf	result91;
    float	shift3;
    bsdf	product12;
    bsdf	result92;
    int	bool36;
    float	val12;
    int	found12;
    float	result93;
    float	result94;
    float	result95;
    bsdf	product13;
    int	outcheck2;
    bsdf	outsurface1;
    bsdf	outreflect;
    bsdf	f3;
    int	bool37;
    vector	uv21;
    vector	output19;
    vector	result96;
    vector	result97;
    vector	result98;
    float	fval116;
    float	fval216;
    float	fval316;
    vector	result99;
    vector	_uv18;
    vector	clr16;
    vector	to1;
    vector	result100;
    vector	result101;
    vector	shift4;
    vector	Value5;
    vector	result102;
    vector	hsv2;
    float	fval117;
    float	fval217;
    float	fval317;
    float	fraction4;
    float	sum6;
    float	fraction5;
    float	product14;
    float	product15;
    vector	vec2;
    vector	rgb2;
    vector	bias2;
    vector	gain2;
    float	inverse2;
    vector	pow2;
    vector	hsv3;
    float	fval118;
    float	fval218;
    float	fval318;
    float	fraction6;
    float	sum7;
    float	fraction7;
    float	product16;
    float	product17;
    vector	vec3;
    vector	rgb3;
    vector	bias3;
    vector	gain3;
    float	inverse3;
    vector	pow3;
    vector	result103;
    float	Value7;
    bsdf	product18;
    int	outcheck3;
    bsdf	outsurface2;
    bsdf	outtrans;
    vector	albedo;
    float	lum4;
    float	eps;
    float	max;
    float	inverse4;
    float	input2;
    float	min;
    bsdf	product19;
    float	scale45;
    int	raylevel;
    int	bool38;
    int	connected1;
    vector	frontN;
    vector	nvec6;
    ShaderLayer	layer2;
    ShaderLayer	result104;
    ShaderLayer	out_struct;
    bsdf	out_F;
    vector	out_Of;
    vector	out_Ce;
    vector	out_P;
    vector	out_N;
    float	out_layeralpha;
    float	out_masks[];
    bsdf	result105;
    vector	result106;
    vector	result107;
    int	condition_out;
    bsdf	var1_out;
    vector	var2_out;
    vector	var3_out;
    vector	albedo1;
    ShaderLayer	layer3;
    bsdf	f4;
    bsdf	product20;
    ShaderLayer	layer4;
    bsdf	result108;
    float	lum5;
    ShaderLayer	layer5;
    float	len1;
    vector	product21;
    vector	product22;
    vector	export_uv1;
    int	bool39;
    string	val13;
    int	found13;
    string	result109;
    string	result110;
    string	result111;
    int	bool40;
    int	bool41;
    vector	uv23;
    vector	output110;
    vector	result112;
    vector	result113;
    vector	result114;
    float	fval119;
    float	fval219;
    float	fval319;
    vector	result115;
    vector	_uv20;
    vector	clr18;
    float	lum6;
    float	diff2;
    float	Value8;
    int	outcheck4;
    float	outval14;
    float	outval24;
    float	Value9;
    int	bool42;
    float	val14;
    int	found14;
    float	result116;
    float	result117;
    float	result118;
    float	product23;
    float	product24;
    float	sum8;
    float	result119;
    float	len2;
    float	product25;
    float	result120;
    vector	vec4;
    int	bool43;
    vector	uv25;
    vector	output111;
    vector	result121;
    vector	result122;
    vector	result123;
    float	fval120;
    float	fval220;
    float	fval320;
    vector	result124;
    vector	_uv22;
    vector	clr20;
    int	bool44;
    string	val15;
    int	found15;
    int	bool45;
    string	result125;
    string	result126;
    string	result127;
    int	bool46;
    vector	uv27;
    vector	output112;
    vector	result128;
    vector	result129;
    vector	result130;
    float	fval121;
    float	fval221;
    float	fval321;
    vector	result131;
    vector	_uv24;
    vector	clr22;
    int	isuvrender;
    string	uvobject;
    string	uvhiresobject;
    int	val16;
    int	found16;
    int	unwrapmethod;
    int	val17;
    int	found17;
    int	flipnormal;
    vector	Ds1;
    vector	result132;
    int	val18;
    int	found18;
    int	usemikkt;
    int	val19;
    int	found19;
    int	ntflipx;
    int	val20;
    int	found20;
    int	ntflipy;
    int	val21;
    int	found21;
    int	ntincludedisp;
    vector	nvec7;
    vector	result133;
    vector	_N4;
    int	connected2;
    vector	result134;
    vector	nvec8;
    vector4	quat2;
    string	tstyle1;
    vector	in_utan1;
    vector	in_vtan1;
    vector	nml1;
    vector	result135;
    vector	uv28;
    vector	utan1;
    vector	vtan1;
    vector	result136;
    vector	result137;
    vector	result138;
    vector	result139;
    int	val22;
    int	found22;
    int	faceforward;
    vector	Ni;
    vector	nn;
    vector	utan2;
    vector	vtan2;
    vector	Nf1;
    vector	result140;
    vector	tangentN1;
    vector	tangentN2;
    vector	nN1;
    vector	result141;
    int	val23;
    int	found23;
    int	samples;
    float	Oc1;
    float	val24;
    int	found24;
    float	occlusionbias;
    float	bias4;
    vector	vec5;
    vector	result142;
    float	val25;
    int	found25;
    float	cavitydistance;
    float	Cv1;
    float	val26;
    int	found26;
    float	cavitybias;
    float	bias5;
    vector	vec6;
    vector	result143;
    vector	result144;
    vector	result145;
    vector	result146;
    vector	result147;
    float	result148;
    float	result149;
    float	result150;
    float	result151;
    int	bool47;
    vector	uv30;
    vector	output113;
    vector	result152;
    vector	result153;
    vector	result154;
    float	fval122;
    float	fval222;
    float	fval322;
    vector	result155;
    vector	result156;
    vector	result157;
    vector	result158;
    ShaderLayer	layer6;
    vector	result159;
    vector	export_diffcolor1;
    float	export_rough1;
    vector	export_ior1;
    float	export_metallness1;
    vector	export_speccolor1;
    vector	export_translucency1;
    vector	export_sss1;
    vector	export_emission1;
    float	export_mask1;
    float	export_fuzz1;
    vector	export_uv2;
    vector	export_dispcolor1;
    vector	export_normal1;
    vector	export_bump1;
    vector	export_ao1;
    vector	export_opacity1;
    ShaderLayer	outlayer;
    vector	outexport_diffcolor;
    float	outexport_rough;
    vector	outexport_ior;
    float	outexport_metallness;
    vector	outexport_speccolor;
    vector	outexport_translucency;
    vector	outexport_sss;
    vector	outexport_emission;
    float	outexport_mask;
    float	outexport_fuzz;
    vector	outexport_uv;
    vector	outexport_dispcolor;
    vector	outexport_normal;
    vector	outexport_bump;
    vector	outexport_ao;
    vector	outexport_opacity;
    vector	Cf1;
    vector	blend1;
    float	val27;
    int	found27;
    float	curvaturescale;
    float	val28;
    int	found28;
    float	curvaturebias;
    int	val29;
    int	found29;
    int	curvatureOcc;
    float	val30;
    int	found30;
    float	curvatureSDist;
    float	K;
    vector	vec7;
    vector	Vd1;
    vector	nn2;
    vector	utan4;
    vector	vtan4;
    matrix3	matx1;
    matrix3	inverse5;
    vector	product26;


    bool1 = (use_opacity != 0);


    found = renderstate("packed:ms_opacval", val);
    if (!found) val = 0;


    bound_ms_opacval = isbound("ms_opacval");
#line 1281 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result = (0 != 0 ? (bound_ms_opacval != 0 ? use_opacity : ms_opacval)
                                  : (bound_ms_opacval != 0 ? ms_opacval : use_opacity));
#line 1296 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result1 = (0 != 0 ? (found != 0 ? result : val)
                                  : (found != 0 ? val : result));
#line 1311 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result2 = (0 != 0 ? (bool1 != 0 ? use_opacity : result1)
                                  : (bool1 != 0 ? result1 : use_opacity));




    check = 0;


    bool2 = (opaccolor_texture != "");


    found1 = renderstate("packed:ms_opac", val1);
    if (!found1) val1 = "";


    bound_ms_opac = isbound("ms_opac");
#line 1339 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result3 = (0 != 0 ? (bound_ms_opac != 0 ? opaccolor_texture : ms_opac)
                                  : (bound_ms_opac != 0 ? ms_opac : opaccolor_texture));
#line 1354 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result4 = (0 != 0 ? (found1 != 0 ? result3 : val1)
                                  : (found1 != 0 ? val1 : result3));
#line 1369 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result5 = (0 != 0 ? (bool2 != 0 ? result4 : opaccolor_texture)
                                  : (bool2 != 0 ? opaccolor_texture : result4));




    outval1 = check;
    outval2 = result5;

    _mat_megascans_shader_simple1_snippet10(outval1, outval2);


    string	_mode = "uv";
    vector	uv1 = vector();
    float	u = 0.0;
    float	v = 0.0;
    float	w = 0.0;
    {


        bool3 = (_mode == "st");


        bound_uv = isbound("uv");


        bound_st = isbound("st");



        uv2 = set(s, t, 0);





        output1 = st;


        if( bound_st == 0 )
            result6 = uv2;
        else
            result6 = output1;


        if( bound_uv == 0 )
            result7 = result6;
        else
            result7 = uv;


        if( bool3 == 0 )
            result8 = result7;
        else
            result8 = uv2;


        assign(fval1,fval2,fval3, result8);


        uv1 = result8;
        u = fval1;
        v = fval2;
        w = fval3;
    }


    vector	_uv = uv1;
    vector	_duv = vector();
    string	_map = result5;
    int	_udim = 1;
    string	_srccolorspace = "auto";
    string	_wrap = "repeat";
    string	_filter = "box";
    float	_width = 1;
    float	_blur = 0;
    float	_pixelblur = 0;
    vector4	_border = { 0, 0, 0, 1 };
    int	_extrapol = 1;
    int	_interp = 0;
    vector4	_defclr = { 1, 1, 1, 0 };
    string	_channel = "";
    int	_ptexface = 0;
    int	_orient = 0;
    vector	clr = vector();
    {


        string	_mode1 = "uv";
        vector	uv3 = vector();
        float	u1 = 0.0;
        float	v1 = 0.0;
        float	w1 = 0.0;
        {


            bool4 = (_mode1 == "st");


            bound_uv1 = isbound("uv");


            bound_st1 = isbound("st");



            uv4 = set(s, t, 0);





            output11 = st;


            if( bound_st1 == 0 )
                result9 = uv4;
            else
                result9 = output11;


            if( bound_uv1 == 0 )
                result10 = result9;
            else
                result10 = uv;


            if( bool4 == 0 )
                result11 = result10;
            else
                result11 = uv4;


            assign(fval11,fval21,fval31, result11);


            uv3 = result11;
            u1 = fval11;
            v1 = fval21;
            w1 = fval31;
        }


        result12 = 1 != 0 ? _uv : uv3;


        _uv1 = result12;


        if (_map != "") {

            int fptex = 0 ? _ptexface : getptextureid();



            string wrapmode = _wrap;
            if (_orient & 0x02) { _uv1.y = 1 - _uv1.y; }
            if (_orient & 0x04) { float x = _uv1.x; _uv1.x = _uv1.y; _uv1.y = x; }
            string _map_udim = _map;
            string ocio = ocio_parsecolorspace(_map);
            if (_udim && has_udim(_map))
                _map_udim = expand_udim(_uv1.x, _uv1.y, _map);
            if (_map_udim == '') { clr1 = set(_defclr); }
            else {
                if (_map_udim != _map) {
                    _uv1.x %= 1.0; _uv1.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient & 0x01) { _uv1.x = 1 - _uv1.x; }
                if (0 != 0) {
                    vector tduv = 0.5 * _duv;
                    if (_orient & 0x04) { float x = tduv.x; tduv.x = tduv.y; tduv.y = x; }
                    clr1 = texture(_map_udim,
                             _uv1.x - tduv.x, _uv1.y - tduv.y,
                             _uv1.x + tduv.x, _uv1.y - tduv.y,
                             _uv1.x + tduv.x, _uv1.y + tduv.y,
                             _uv1.x - tduv.x, _uv1.y + tduv.y,
                            "wrap", wrapmode, "filter", _filter,
                            "width", _width, "border", _border,
                            "extrapolate", _extrapol, "lerp", _interp,
                            "channel", _channel, "face", fptex,
                            "blur", _blur, "pixelblur", _pixelblur,
                            "srccolorspace", ocio == '' ? _srccolorspace : 'linear');
                } else {
                    clr1 = texture(_map_udim, _uv1.x, _uv1.y, "wrap", wrapmode,
                            "filter", _filter, "width", _width,
                            "border", _border, "extrapolate", _extrapol,
                            "channel", _channel, "face", fptex,
                            "lerp", _interp,
                            "blur", _blur, "pixelblur", _pixelblur,
                            "srccolorspace", ocio == '' ? _srccolorspace : 'linear');
                }
                if (ocio != '')
                    clr1 = ocio_transform(ocio, "scene_linear", clr1);
            }
        } else {
           clr1 = set(_defclr);
        }



        clr = clr1;
    }


    surface = clr;


    outcheck = outval1;
    outsurface = surface;

    _mat_megascans_shader_simple1_snippet2(outcheck, outsurface);
#line 1592 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result13 = (0 != 0 ? (result2 != 0 ? { 1, 1, 1 } : outsurface)
                                  : (result2 != 0 ? outsurface : { 1, 1, 1 }));




    bool5 = (trans_texture != "");


    found2 = renderstate("packed:ms_trans", val2);
    if (!found2) val2 = "";


    bound_ms_trans = isbound("ms_trans");
#line 1617 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result14 = (0 != 0 ? (bound_ms_trans != 0 ? trans_texture : ms_trans)
                                  : (bound_ms_trans != 0 ? ms_trans : trans_texture));
#line 1632 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result15 = (0 != 0 ? (found2 != 0 ? result14 : val2)
                                  : (found2 != 0 ? val2 : result14));
#line 1647 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result16 = (0 != 0 ? (bool5 != 0 ? result15 : trans_texture)
                                  : (bool5 != 0 ? trans_texture : result15));




    bool6 = (result16 != "\"\"");


    check1 = 0;


    check2 = 0;


    outval11 = check2;
    outval21 = albedo_texture;

    _mat_megascans_shader_simple1_snippet14(outval11, outval21);


    found3 = renderstate("packed:ms_diffuse", val3);
    if (!found3) val3 = "";


    bool7 = (val3 != "");


    bound_ms_diffuse = isbound("ms_diffuse");
#line 1687 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result17 = (0 != 0 ? (bound_ms_diffuse != 0 ? albedo_texture : ms_diffuse)
                                  : (bound_ms_diffuse != 0 ? ms_diffuse : albedo_texture));
#line 1702 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result18 = (0 != 0 ? (bool7 != 0 ? result17 : val3)
                                  : (bool7 != 0 ? val3 : result17));
#line 1717 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result19 = (0 != 0 ? (outval11 != 0 ? result18 : albedo_texture)
                                  : (outval11 != 0 ? albedo_texture : result18));




    outval12 = check1;
    outval22 = result19;

    _mat_megascans_shader_simple1_snippet13(outval12, outval22);


    check3 = 0;


    outval13 = check3;
    outval23 = ao_texture;

    _mat_megascans_shader_simple1_snippet15(outval13, outval23);


    found4 = renderstate("packed:ms_ao", val4);
    if (!found4) val4 = "";


    bool8 = (val4 != "");


    bound_ms_ao = isbound("ms_ao");
#line 1757 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result20 = (0 != 0 ? (bound_ms_ao != 0 ? ao_texture : ms_ao)
                                  : (bound_ms_ao != 0 ? ms_ao : ao_texture));
#line 1772 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result21 = (0 != 0 ? (bool8 != 0 ? result20 : val4)
                                  : (bool8 != 0 ? val4 : result20));
#line 1787 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result22 = (0 != 0 ? (outval13 != 0 ? ao_texture : result21)
                                  : (outval13 != 0 ? result21 : ao_texture));




    bool9 = (result22 != "\"\"");


    found5 = renderstate("packed:packed_id", val5);
    if (!found5) val5 = 0;


    vector	_uv2 = uv1;
    vector	_duv1 = vector();
    string	_map1 = result19;
    int	_udim1 = 1;
    string	_srccolorspace1 = "auto";
    string	_wrap1 = "repeat";
    string	_filter1 = "box";
    float	_width1 = 1;
    float	_blur1 = 0;
    float	_pixelblur1 = 0;
    vector4	_border1 = { 0, 0, 0, 1 };
    int	_extrapol1 = 1;
    int	_interp1 = 0;
    vector4	_defclr1 = { 0, 0, 0, 0 };
    string	_channel1 = "";
    int	_ptexface1 = 0;
    int	_orient1 = 0;
    vector	clr2 = vector();
    {


        string	_mode2 = "uv";
        vector	uv5 = vector();
        float	u2 = 0.0;
        float	v2 = 0.0;
        float	w2 = 0.0;
        {


            bool10 = (_mode2 == "st");


            bound_uv2 = isbound("uv");


            bound_st2 = isbound("st");



            uv6 = set(s, t, 0);





            output12 = st;


            if( bound_st2 == 0 )
                result23 = uv6;
            else
                result23 = output12;


            if( bound_uv2 == 0 )
                result24 = result23;
            else
                result24 = uv;


            if( bool10 == 0 )
                result25 = result24;
            else
                result25 = uv6;


            assign(fval12,fval22,fval32, result25);


            uv5 = result25;
            u2 = fval12;
            v2 = fval22;
            w2 = fval32;
        }


        result26 = 1 != 0 ? _uv2 : uv5;


        _uv3 = result26;


        if (_map1 != "") {

            int fptex = 0 ? _ptexface1 : getptextureid();



            string wrapmode = _wrap1;
            if (_orient1 & 0x02) { _uv3.y = 1 - _uv3.y; }
            if (_orient1 & 0x04) { float x = _uv3.x; _uv3.x = _uv3.y; _uv3.y = x; }
            string _map_udim = _map1;
            string ocio = ocio_parsecolorspace(_map1);
            if (_udim1 && has_udim(_map1))
                _map_udim = expand_udim(_uv3.x, _uv3.y, _map1);
            if (_map_udim == '') { clr3 = set(_defclr1); }
            else {
                if (_map_udim != _map1) {
                    _uv3.x %= 1.0; _uv3.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient1 & 0x01) { _uv3.x = 1 - _uv3.x; }
                if (0 != 0) {
                    vector tduv1 = 0.5 * _duv1;
                    if (_orient1 & 0x04) { float x = tduv1.x; tduv1.x = tduv1.y; tduv1.y = x; }
                    clr3 = texture(_map_udim,
                             _uv3.x - tduv1.x, _uv3.y - tduv1.y,
                             _uv3.x + tduv1.x, _uv3.y - tduv1.y,
                             _uv3.x + tduv1.x, _uv3.y + tduv1.y,
                             _uv3.x - tduv1.x, _uv3.y + tduv1.y,
                            "wrap", wrapmode, "filter", _filter1,
                            "width", _width1, "border", _border1,
                            "extrapolate", _extrapol1, "lerp", _interp1,
                            "channel", _channel1, "face", fptex,
                            "blur", _blur1, "pixelblur", _pixelblur1,
                            "srccolorspace", ocio == '' ? _srccolorspace1 : 'linear');
                } else {
                    clr3 = texture(_map_udim, _uv3.x, _uv3.y, "wrap", wrapmode,
                            "filter", _filter1, "width", _width1,
                            "border", _border1, "extrapolate", _extrapol1,
                            "channel", _channel1, "face", fptex,
                            "lerp", _interp1,
                            "blur", _blur1, "pixelblur", _pixelblur1,
                            "srccolorspace", ocio == '' ? _srccolorspace1 : 'linear');
                }
                if (ocio != '')
                    clr3 = ocio_transform(ocio, "scene_linear", clr3);
            }
        } else {
           clr3 = set(_defclr1);
        }



        clr2 = clr3;
    }


    vector	_clr = clr2;
    {


        to = ocio_transform("Utility - Linear - sRGB", "acescg", _clr);


        if( 1 == 0 )
            result27 = _clr;
        else
            result27 = to;


        if( 1 == 0 )
            result28 = _clr;
        else
            result28 = result27;


        _clr = result28;
    }



        if (1)
        	rand = random(val5);
        else
           rand = rand(val5);





    shift = fit(rand, 0, 1, 0.94999999999999996, 1.05);


    added = val5 + 7;



        if (1)
        	rand1 = random(added);
        else
           rand1 = rand(added);





    shift1 = fit(rand1, { 0, 0, 0 }, { 1, 1, 1 }, { 0.45000000000000001, 0.45000000000000001, 0.45000000000000001 }, { 0.55000000000000004, 0.55000000000000004, 0.55000000000000004 });


    vector	_ClrIn = _clr;
    float	_Shift = 0;
    float	_Saturation = 1;
    float	_Value = shift;
    vector	_Bias = { 0.5, 0.5, 0.5 };
    vector	_Gain = shift1;
    float	_Gamma = 1;
    vector	ClrOut = vector();
    {


        hsv = rgbtohsv(_ClrIn);


        assign(fval13,fval23,fval33, hsv);


        fraction = frac(_Shift);


        sum = fval13 + fraction;


        fraction1 = frac(sum);


        product = fval23 * _Saturation;


        product1 = fval33 * _Value;


        vec = set(fraction1,product,product1);


        rgb = hsvtorgb(vec);
#line 2037 "/mat/megascans_shader_simple1/SurfaceVexCode"
           float cr = vop_bias(rgb.x, _Bias.x);
           float cg = vop_bias(rgb.y, _Bias.y);
           float cb = vop_bias(rgb.z, _Bias.z);
           bias = set(cr, cg, cb);
#line 2062 "/mat/megascans_shader_simple1/SurfaceVexCode"
           float cr1 = vop_gain(bias.x, _Gain.x);
           float cg1 = vop_gain(bias.y, _Gain.y);
           float cb1 = vop_gain(bias.z, _Gain.z);
           gain = set(cr1, cg1, cb1);
#line 2078 "/mat/megascans_shader_simple1/SurfaceVexCode"
          inverse = 1.0 / _Gamma;





        pow = pow((gain), inverse);


        ClrOut = pow;
    }
#line 2100 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result29 = (0 != 0 ? (val5 != 0 ? _clr : ClrOut)
                                  : (val5 != 0 ? ClrOut : _clr));




    diff = result29;


    vector	_uv4 = uv1;
    vector	_duv2 = vector();
    string	_map2 = result22;
    int	_udim2 = 1;
    string	_srccolorspace2 = "auto";
    string	_wrap2 = "repeat";
    string	_filter2 = "box";
    float	_width2 = 1;
    float	_blur2 = 0;
    float	_pixelblur2 = 0;
    vector4	_border2 = { 0, 0, 0, 1 };
    int	_extrapol2 = 1;
    int	_interp2 = 0;
    vector4	_defclr2 = { 0, 0, 0, 0 };
    string	_channel2 = "";
    int	_ptexface2 = 0;
    int	_orient2 = 0;
    vector	clr4 = vector();
    {


        string	_mode3 = "uv";
        vector	uv7 = vector();
        float	u3 = 0.0;
        float	v3 = 0.0;
        float	w3 = 0.0;
        {


            bool11 = (_mode3 == "st");


            bound_uv3 = isbound("uv");


            bound_st3 = isbound("st");



            uv8 = set(s, t, 0);





            output13 = st;


            if( bound_st3 == 0 )
                result30 = uv8;
            else
                result30 = output13;


            if( bound_uv3 == 0 )
                result31 = result30;
            else
                result31 = uv;


            if( bool11 == 0 )
                result32 = result31;
            else
                result32 = uv8;


            assign(fval14,fval24,fval34, result32);


            uv7 = result32;
            u3 = fval14;
            v3 = fval24;
            w3 = fval34;
        }


        result33 = 1 != 0 ? _uv4 : uv7;


        _uv5 = result33;


        if (_map2 != "") {

            int fptex = 0 ? _ptexface2 : getptextureid();



            string wrapmode = _wrap2;
            if (_orient2 & 0x02) { _uv5.y = 1 - _uv5.y; }
            if (_orient2 & 0x04) { float x = _uv5.x; _uv5.x = _uv5.y; _uv5.y = x; }
            string _map_udim = _map2;
            string ocio = ocio_parsecolorspace(_map2);
            if (_udim2 && has_udim(_map2))
                _map_udim = expand_udim(_uv5.x, _uv5.y, _map2);
            if (_map_udim == '') { clr5 = set(_defclr2); }
            else {
                if (_map_udim != _map2) {
                    _uv5.x %= 1.0; _uv5.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient2 & 0x01) { _uv5.x = 1 - _uv5.x; }
                if (0 != 0) {
                    vector tduv2 = 0.5 * _duv2;
                    if (_orient2 & 0x04) { float x = tduv2.x; tduv2.x = tduv2.y; tduv2.y = x; }
                    clr5 = texture(_map_udim,
                             _uv5.x - tduv2.x, _uv5.y - tduv2.y,
                             _uv5.x + tduv2.x, _uv5.y - tduv2.y,
                             _uv5.x + tduv2.x, _uv5.y + tduv2.y,
                             _uv5.x - tduv2.x, _uv5.y + tduv2.y,
                            "wrap", wrapmode, "filter", _filter2,
                            "width", _width2, "border", _border2,
                            "extrapolate", _extrapol2, "lerp", _interp2,
                            "channel", _channel2, "face", fptex,
                            "blur", _blur2, "pixelblur", _pixelblur2,
                            "srccolorspace", ocio == '' ? _srccolorspace2 : 'linear');
                } else {
                    clr5 = texture(_map_udim, _uv5.x, _uv5.y, "wrap", wrapmode,
                            "filter", _filter2, "width", _width2,
                            "border", _border2, "extrapolate", _extrapol2,
                            "channel", _channel2, "face", fptex,
                            "lerp", _interp2,
                            "blur", _blur2, "pixelblur", _pixelblur2,
                            "srccolorspace", ocio == '' ? _srccolorspace2 : 'linear');
                }
                if (ocio != '')
                    clr5 = ocio_transform(ocio, "scene_linear", clr5);
            }
        } else {
           clr5 = set(_defclr2);
        }



        clr4 = clr5;
    }


    lum = luminance(clr4);


    shift2 = fit(lum, 0, 1, 0.5, 1);


    product2 = result29 * shift2;
#line 2265 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result34 = (0 != 0 ? (bool9 != 0 ? product2 : diff)
                                  : (bool9 != 0 ? diff : product2));




    vector	_result = result34;
    int	_outval1 = outval11;
    float	Value1 = 0.0;
    {


        vector	_ClrIn1 = _result;
        float	_Shift1 = Shift;
        float	_Saturation1 = Saturation;
        float	_Value1 = Value;
        vector	_Bias1 = Bias;
        vector	_Gain1 = Gain;
        float	_Gamma1 = Gamma;
        vector	ClrOut1 = vector();
        {


            hsv1 = rgbtohsv(_ClrIn1);


            assign(fval15,fval25,fval35, hsv1);


            fraction2 = frac(_Shift1);


            sum1 = fval15 + fraction2;


            fraction3 = frac(sum1);


            product3 = fval25 * _Saturation1;


            product4 = fval35 * _Value1;


            vec1 = set(fraction3,product3,product4);


            rgb1 = hsvtorgb(vec1);
#line 2324 "/mat/megascans_shader_simple1/SurfaceVexCode"
               float cr2 = vop_bias(rgb1.x, _Bias1.x);
               float cg2 = vop_bias(rgb1.y, _Bias1.y);
               float cb2 = vop_bias(rgb1.z, _Bias1.z);
               bias1 = set(cr2, cg2, cb2);
#line 2349 "/mat/megascans_shader_simple1/SurfaceVexCode"
               float cr3 = vop_gain(bias1.x, _Gain1.x);
               float cg3 = vop_gain(bias1.y, _Gain1.y);
               float cb3 = vop_gain(bias1.z, _Gain1.z);
               gain1 = set(cr3, cg3, cb3);
#line 2365 "/mat/megascans_shader_simple1/SurfaceVexCode"
              inverse1 = 1.0 / _Gamma1;





            pow1 = pow((gain1), inverse1);


            ClrOut1 = pow1;
        }


        if( _outval1 == 0 )
            result35 = _result;
        else
            result35 = ClrOut1;


        _result = result35;
        Value1 = Value;
    }





    nvec = normalize(N);





    bool12 = (normal_texture != "");


    found6 = renderstate("packed:ms_normal", val6);
    if (!found6) val6 = "";


    bound_ms_normal = isbound("ms_normal");
#line 2417 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result36 = (0 != 0 ? (bound_ms_normal != 0 ? normal_texture : ms_normal)
                                  : (bound_ms_normal != 0 ? ms_normal : normal_texture));
#line 2432 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result37 = (0 != 0 ? (found6 != 0 ? result36 : val6)
                                  : (found6 != 0 ? val6 : result36));
#line 2447 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result38 = (0 != 0 ? (bool12 != 0 ? result37 : normal_texture)
                                  : (bool12 != 0 ? normal_texture : result37));




    vector	_P = P;
    vector	_N = nvec;
    vector	_uv6 = uv1;
    string	_type = "normal";
    string	_texcolorspace = "linear";
    string	_vectorspace = "uvtangent";
    string	_channelorder = "xyz";
    float	_offset = -0.5;
    float	_scale = normal_mult;
    string	_texture = result38;
    int	_udim3 = 1;
    string	_texwrap = "repeat";
    string	_texfilter = "gauss";
    float	_texfilterwidth = 1;
    int	_texchannel = 0;
    string	_teximageplane = "";
    int	_normalspace = 0;
    int	_normalflipx = 0;
    int	_normalflipy = 0;
    vector	outP = vector();
    vector	outN = vector();
    vector	doffset = vector();
    float	ddist = 0.0;
    {


        string	_mode4 = "uv";
        vector	uv9 = vector();
        float	u4 = 0.0;
        float	v4 = 0.0;
        float	w4 = 0.0;
        {


            bool13 = (_mode4 == "st");


            bound_uv4 = isbound("uv");


            bound_st4 = isbound("st");



            uv10 = set(s, t, 0);





            output14 = st;


            if( bound_st4 == 0 )
                result39 = uv10;
            else
                result39 = output14;


            if( bound_uv4 == 0 )
                result40 = result39;
            else
                result40 = uv;


            if( bool13 == 0 )
                result41 = result40;
            else
                result41 = uv10;


            assign(fval16,fval26,fval36, result41);


            uv9 = result41;
            u4 = fval16;
            v4 = fval26;
            w4 = fval36;
        }


        result42 = 1 != 0 ? _uv6 : uv9;


        assign(fval17,fval27,fval37, result42);


        if (_texture != "") {

            float myS = 1 ? fval17 : s;
            float myT = 1 ? fval27 : t;
            int fptex = 0 ? 0 : getptextureid();





            string wrapmode = _texwrap;
            if (0 & 0x01) { myS = 1 - myS; }
            if (0 & 0x02) { myT = 1 - myT; }
            if (0 & 0x04) { float x = myS; myS = myT; myT = x; }
            string map_udim = _texture;
            string ocio = ocio_parsecolorspace(_texture);
            if (_udim3 && has_udim(_texture)) { map_udim = expand_udim(myS, myT, _texture); }
            if (map_udim == '') { clr6 = set({ 0, 0, 0, 0 }); }
            else {
                if (map_udim != _texture) {
                    myS %= 1.0; myT %= 1.0;
                    wrapmode = 'streak';
                }
                if (0 != 0 && 0 != 0) {
                    float tds = 0.0*0.5, tdt = 0.0*0.5;
                    if (0 & 0x04) { float x = tds; tds = tdt; tdt = x; }
                    clr6 = texture(map_udim,
                             myS - tds, myT - tdt,
                             myS + tds, myT - tdt,
                             myS + tds, myT + tdt,
                             myS - tds, myT + tdt,
                            "wrap", wrapmode, "filter", _texfilter,
                            "width", _texfilterwidth, "border", { 0, 0, 0, 1 },
                            "extrapolate", 1, "lerp", 0,
                            "channel", _teximageplane, "face", fptex,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", ocio == '' ? _texcolorspace : 'linear');
                } else {
                    clr6 = texture(map_udim, myS, myT, "wrap", wrapmode,
                            "filter", _texfilter, "width", _texfilterwidth,
                            "border", { 0, 0, 0, 1 }, "extrapolate", 1,
                            "channel", _teximageplane, "face", fptex,
                            "lerp", 0,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", ocio == '' ? _texcolorspace : 'linear');
                }
            }
            if (ocio != '') clr6 = ocio_transform(ocio, 'scene_linear', clr6);
        } else {
           clr6 = set({ 0, 0, 0, 0 });
        }


        string	_string = _texture;
        int	length = 0;
        {


            Value2 = 0;


            outstr = _string;
            outresultcharacter = Value2;

            _mat_megascans_shader_simple1_displacetexture1_strlen1_snippet1(outstr, outresultcharacter);


            length = outresultcharacter;
        }


        bool14 = (length > 0);


        product5 = _scale * bool14;


        vector	_P1 = _P;
        vector	_N1 = _N;
        vector	_uv7 = result42;
        vector	_value = clr6;
        string	_type1 = _type;
        string	_vectorspace1 = _vectorspace;
        string	_channelorder1 = _channelorder;
        float	_offset1 = _offset;
        float	_scale1 = product5;
        int	_channel3 = _texchannel;
        int	_normalspace1 = _normalspace;
        int	_normalflipx1 = _normalflipx;
        int	_normalflipy1 = _normalflipy;
        vector	outP1 = vector();
        vector	outN1 = vector();
        vector	doffset1 = vector();
        float	ddist1 = 0.0;
        {


            bool15 = (_type1 == "normal");


            bool16 = (_type1 == "disp");


            scaled = (bool16 + 0) * 2 + 0;


            bool17 = (_type1 == "vectordisp");


            scaled1 = (bool17 + 0) * 3 + 0;


            sum2 = bool15 + scaled + scaled1;


            result43 = 1 != 0 ? _P1 : P;








            result44 = 1 != 0 ? _N1 : N;


            nvec1 = normalize(result44);


            lum1 = luminance(_value);


            assign(fval18,fval28,fval38, _value);


            if( _channel3 == 0 )
                result45 = lum1;
            else if( _channel3 == 1 )
                result45 = fval18;
            else if( _channel3 == 2 )
                result45 = fval28;
            else
                result45 = fval38;


            sum3 = result45 + _offset1;


            vop_displaceAlongNormal((1 != 0) ? result43 : P,
            			 (1 != 0) ? nvec1 : normalize(N),
            			 sum3, _scale1, 0, 0,
            			 1, 0, 0, dispP, dispN);





            product6 = _value * _scale1;


            outorder = _channelorder1;
            outvec = product6;

            _mat_megascans_shader_simple1_displacetexture1_displace2_swizzle(outorder, outvec);


            result46 = 1 != 0 ? _uv7 : uv;


            vector	_result1 = result46;
            vector	_nvec = nvec1;
            string	__vectorspace = _vectorspace1;
            matrix3	result_2 = matrix3();
            {


                bool18 = (__vectorspace == "world");


                bool19 = (__vectorspace == "object");


                string	_tstyle = "uv";
                vector	_uv8 = _result1;
                vector	_N2 = _nvec;
                vector	_utan = vector();
                vector	_vtan = vector();
                float	_angle = 0.0;
                {


                    connected = 0 ? 1 : 0;


                    result47 = 1 != 0 ? _N2 : N;


                    nvec2 = normalize(result47);


                    quat = quaternion(_angle, nvec2);


                    tstyle = _tstyle;


                    in_utan = _utan;


                    in_vtan = _vtan;


                    nml = nvec2;


                    result48 = 1 != 0 ? _uv8 : uv;


                    uv11 = result48;


                    vop_computeTangents(tstyle, nml, uv11, in_utan, in_vtan, utan, vtan);


                    result49 = qrotate(quat, utan);
#line 2777 "/mat/megascans_shader_simple1/SurfaceVexCode"
                        result50 = (0 != 0 ? (connected != 0 ? utan : result49)
                                                  : (connected != 0 ? result49 : utan));




                    result51 = qrotate(quat, vtan);
#line 2795 "/mat/megascans_shader_simple1/SurfaceVexCode"
                        result52 = (0 != 0 ? (connected != 0 ? vtan : result51)
                                                  : (connected != 0 ? result51 : vtan));




                    _utan = result50;
                    _vtan = result52;
                }


                assign(fval19,fval29,fval39, _utan);


                assign(fval110,fval210,fval310, _vtan);


                assign(fval111,fval211,fval311, _nvec);


                matx = set(fval19, fval29, fval39,
                            fval110, fval210, fval310,
                            fval111, fval211, fval311);


                xform = getspace("space:object", "space:current");


                m3 = (matrix3)xform;


                if( bool19 == 0 )
                    result53 = matx;
                else
                    result53 = m3;


                xform1 = getspace("space:world", "space:current");


                m31 = (matrix3)xform1;


                if( bool18 == 0 )
                    result54 = result53;
                else
                    result54 = m31;


                result_2 = result54;
            }


            product7 = outvec * result_2;


            sum4 = result43 + product7;





            if( sum2 == 0 )
                result55 = result43;
            else if( sum2 == 1 )
                result55 = result43;
            else if( sum2 == 2 )
                result55 = dispP;
            else
                result55 = sum4;


            vop_displaceAlongNormal((1 != 0) ? result43 : P,
            			 (1 != 0) ? nvec1 : normalize(N),
            			 sum3, _scale1, 0, 0,
            			 1, 0, 1, dispP1, dispN1);





            Ns = _value;
            if (_normalspace1 == 0) { Ns = vop_fromUnitNormal(Ns); }


            Nf = Ns;
            if (_normalflipx1) { Nf.x = -Nf.x; }
            if (_normalflipy1) { Nf.y = -Nf.y; }



            product8 = Nf * result_2;


            nvec3 = normalize(product8);


            dotprod = dot(nvec3, nvec1);


            trig = acos(1*dotprod - 0);


            crossprod = cross(nvec1, nvec3);


            nvec4 = normalize(crossprod);


            quat1 = quaternion(trig, nvec4);


            blend = slerp({ 0, 0, 0, 1 }, quat1, _scale1);


            result56 = qrotate(blend, nvec1);








            vector myP  = 1  ? sum4  : P;
            vector myN  = 0  ? vector()  : N;
            vector myNg = 0 ? vector() : Ng;
            newN = computenormal(myP, myN, myNg, "extrapolate", 0,
                                 "smooth", 1);





            if( sum2 == 0 )
                result57 = dispN1;
            else if( sum2 == 1 )
                result57 = result56;
            else if( sum2 == 2 )
                result57 = dispN;
            else
                result57 = newN;


            Value3 = { 0, 0, 0 };


            diff1 = dispP - result43;


            if( sum2 == 0 )
                result58 = Value3;
            else if( sum2 == 1 )
                result58 = Value3;
            else if( sum2 == 2 )
                result58 = diff1;
            else
                result58 = product7;


            Value4 = 0;


            product9 = sum3 * _scale1;


            len = length(product7);


            if( sum2 == 0 )
                result59 = Value4;
            else if( sum2 == 1 )
                result59 = Value4;
            else if( sum2 == 2 )
                result59 = product9;
            else
                result59 = len;


            outP1 = result55;
            outN1 = result57;
            doffset1 = result58;
            ddist1 = result59;
        }


        outP = outP1;
        outN = outN1;
        doffset = doffset1;
        ddist = ddist1;
    }





    nvec5 = normalize(outN);



    vector tnN = 1 ? nvec5 : normalize(N);
    vector tnNg = dot(tnN, Ng) > 0 ? Ng : -Ng;





    if(1)
    {
        tnN = frontface(tnN, I);
        tnNg = frontface(tnNg, I);
    }

    if ("diffuse" != "translucent")
    {
        if (0 > 0)
            f = 2.0*diffuse(tnN, tnNg, 0, "label", "diffuse");
        else
            f = 2.0*diffuse(tnN, tnNg, "label", "diffuse");
    }
    else
    {
        f = 2.0*translucent(tnN, tnNg, "label", "diffuse");
    }

    init_layer(layer1);
    f *= _result;
    layer1.F = f;


    bool20 = (metallic_texture != "");


    found7 = renderstate("packed:ms_metal", val7);
    if (!found7) val7 = "";


    bool21 = (val7 != "");


    bound_ms_metal = isbound("ms_metal");
#line 3047 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result60 = (0 != 0 ? (bound_ms_metal != 0 ? metallic_texture : ms_metal)
                                  : (bound_ms_metal != 0 ? ms_metal : metallic_texture));
#line 3062 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result61 = (0 != 0 ? (bool21 != 0 ? result60 : val7)
                                  : (bool21 != 0 ? val7 : result60));
#line 3077 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result62 = (0 != 0 ? (bool20 != 0 ? result61 : metallic_texture)
                                  : (bool20 != 0 ? metallic_texture : result61));




    bool22 = (result62 != "");


    bool23 = (rough_texture != "");


    found8 = renderstate("packed:ms_rough", val8);
    if (!found8) val8 = "";


    bool24 = (val8 != "");


    bound_ms_rough = isbound("ms_rough");
#line 3108 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result63 = (0 != 0 ? (bound_ms_rough != 0 ? rough_texture : ms_rough)
                                  : (bound_ms_rough != 0 ? ms_rough : rough_texture));
#line 3123 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result64 = (0 != 0 ? (bool24 != 0 ? result63 : val8)
                                  : (bool24 != 0 ? val8 : result63));
#line 3138 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result65 = (0 != 0 ? (bool23 != 0 ? result64 : rough_texture)
                                  : (bool23 != 0 ? rough_texture : result64));




    vector	_uv9 = uv1;
    vector	_duv3 = vector();
    string	_map3 = result65;
    int	_udim4 = 1;
    string	_srccolorspace3 = "auto";
    string	_wrap3 = "repeat";
    string	_filter3 = "box";
    float	_width3 = 1;
    float	_blur3 = 0;
    float	_pixelblur3 = 0;
    vector4	_border3 = { 0, 0, 0, 1 };
    int	_extrapol3 = 1;
    int	_interp3 = 0;
    vector4	_defclr3 = { 0, 0, 0, 0 };
    string	_channel4 = "";
    int	_ptexface3 = 0;
    int	_orient3 = 0;
    vector	clr7 = vector();
    {


        string	_mode5 = "uv";
        vector	uv12 = vector();
        float	u5 = 0.0;
        float	v5 = 0.0;
        float	w5 = 0.0;
        {


            bool25 = (_mode5 == "st");


            bound_uv5 = isbound("uv");


            bound_st5 = isbound("st");



            uv13 = set(s, t, 0);





            output15 = st;


            if( bound_st5 == 0 )
                result66 = uv13;
            else
                result66 = output15;


            if( bound_uv5 == 0 )
                result67 = result66;
            else
                result67 = uv;


            if( bool25 == 0 )
                result68 = result67;
            else
                result68 = uv13;


            assign(fval112,fval212,fval312, result68);


            uv12 = result68;
            u5 = fval112;
            v5 = fval212;
            w5 = fval312;
        }


        result69 = 1 != 0 ? _uv9 : uv12;


        _uv10 = result69;


        if (_map3 != "") {

            int fptex = 0 ? _ptexface3 : getptextureid();



            string wrapmode = _wrap3;
            if (_orient3 & 0x02) { _uv10.y = 1 - _uv10.y; }
            if (_orient3 & 0x04) { float x = _uv10.x; _uv10.x = _uv10.y; _uv10.y = x; }
            string _map_udim = _map3;
            string ocio = ocio_parsecolorspace(_map3);
            if (_udim4 && has_udim(_map3))
                _map_udim = expand_udim(_uv10.x, _uv10.y, _map3);
            if (_map_udim == '') { clr8 = set(_defclr3); }
            else {
                if (_map_udim != _map3) {
                    _uv10.x %= 1.0; _uv10.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient3 & 0x01) { _uv10.x = 1 - _uv10.x; }
                if (0 != 0) {
                    vector tduv3 = 0.5 * _duv3;
                    if (_orient3 & 0x04) { float x = tduv3.x; tduv3.x = tduv3.y; tduv3.y = x; }
                    clr8 = texture(_map_udim,
                             _uv10.x - tduv3.x, _uv10.y - tduv3.y,
                             _uv10.x + tduv3.x, _uv10.y - tduv3.y,
                             _uv10.x + tduv3.x, _uv10.y + tduv3.y,
                             _uv10.x - tduv3.x, _uv10.y + tduv3.y,
                            "wrap", wrapmode, "filter", _filter3,
                            "width", _width3, "border", _border3,
                            "extrapolate", _extrapol3, "lerp", _interp3,
                            "channel", _channel4, "face", fptex,
                            "blur", _blur3, "pixelblur", _pixelblur3,
                            "srccolorspace", ocio == '' ? _srccolorspace3 : 'linear');
                } else {
                    clr8 = texture(_map_udim, _uv10.x, _uv10.y, "wrap", wrapmode,
                            "filter", _filter3, "width", _width3,
                            "border", _border3, "extrapolate", _extrapol3,
                            "channel", _channel4, "face", fptex,
                            "lerp", _interp3,
                            "blur", _blur3, "pixelblur", _pixelblur3,
                            "srccolorspace", ocio == '' ? _srccolorspace3 : 'linear');
                }
                if (ocio != '')
                    clr8 = ocio_transform(ocio, "scene_linear", clr8);
            }
        } else {
           clr8 = set(_defclr3);
        }



        clr7 = clr8;
    }


    lum2 = luminance(clr7);


    found9 = renderstate("packed:ms_rscale", val9);
    if (!found9) val9 = 0;


    bool26 = (ms_rscale != 0);
#line 3301 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result70 = (0 != 0 ? (bool26 != 0 ? rough : ms_rscale)
                                  : (bool26 != 0 ? ms_rscale : rough));
#line 3316 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result71 = (0 != 0 ? (found9 != 0 ? result70 : val9)
                                  : (found9 != 0 ? val9 : result70));




    bool27 = (rough != 1);
#line 3334 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result72 = (0 != 0 ? (bool27 != 0 ? result71 : rough)
                                  : (bool27 != 0 ? rough : result71));




    product10 = lum2 * result71 * result72;


    clamp = clamp(product10, 0, 0.99990000000000001);


    bool28 = (ior_texture != "");


    found10 = renderstate("packed:ms_ior", val10);
    if (!found10) val10 = "";


    bool29 = (val10 != "");


    bound_ms_ior = isbound("ms_ior");
#line 3368 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result73 = (0 != 0 ? (bound_ms_ior != 0 ? ior_texture : ms_ior)
                                  : (bound_ms_ior != 0 ? ms_ior : ior_texture));
#line 3383 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result74 = (0 != 0 ? (bool29 != 0 ? result73 : val10)
                                  : (bool29 != 0 ? val10 : result73));
#line 3398 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result75 = (0 != 0 ? (bool28 != 0 ? result74 : ior_texture)
                                  : (bool28 != 0 ? ior_texture : result74));




    vector	_uv11 = uv1;
    vector	_duv4 = vector();
    string	_map4 = result75;
    int	_udim5 = 1;
    string	_srccolorspace4 = "auto";
    string	_wrap4 = "repeat";
    string	_filter4 = "box";
    float	_width4 = 1;
    float	_blur4 = 0;
    float	_pixelblur4 = 0;
    vector4	_border4 = { 0, 0, 0, 1 };
    int	_extrapol4 = 1;
    int	_interp4 = 0;
    vector4	_defclr4 = { 0, 0, 0, 0 };
    string	_channel5 = "";
    int	_ptexface4 = 0;
    int	_orient4 = 0;
    vector	clr9 = vector();
    {


        string	_mode6 = "uv";
        vector	uv14 = vector();
        float	u6 = 0.0;
        float	v6 = 0.0;
        float	w6 = 0.0;
        {


            bool30 = (_mode6 == "st");


            bound_uv6 = isbound("uv");


            bound_st6 = isbound("st");



            uv15 = set(s, t, 0);





            output16 = st;


            if( bound_st6 == 0 )
                result76 = uv15;
            else
                result76 = output16;


            if( bound_uv6 == 0 )
                result77 = result76;
            else
                result77 = uv;


            if( bool30 == 0 )
                result78 = result77;
            else
                result78 = uv15;


            assign(fval113,fval213,fval313, result78);


            uv14 = result78;
            u6 = fval113;
            v6 = fval213;
            w6 = fval313;
        }


        result79 = 1 != 0 ? _uv11 : uv14;


        _uv12 = result79;


        if (_map4 != "") {

            int fptex = 0 ? _ptexface4 : getptextureid();



            string wrapmode = _wrap4;
            if (_orient4 & 0x02) { _uv12.y = 1 - _uv12.y; }
            if (_orient4 & 0x04) { float x = _uv12.x; _uv12.x = _uv12.y; _uv12.y = x; }
            string _map_udim = _map4;
            string ocio = ocio_parsecolorspace(_map4);
            if (_udim5 && has_udim(_map4))
                _map_udim = expand_udim(_uv12.x, _uv12.y, _map4);
            if (_map_udim == '') { clr10 = set(_defclr4); }
            else {
                if (_map_udim != _map4) {
                    _uv12.x %= 1.0; _uv12.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient4 & 0x01) { _uv12.x = 1 - _uv12.x; }
                if (0 != 0) {
                    vector tduv4 = 0.5 * _duv4;
                    if (_orient4 & 0x04) { float x = tduv4.x; tduv4.x = tduv4.y; tduv4.y = x; }
                    clr10 = texture(_map_udim,
                             _uv12.x - tduv4.x, _uv12.y - tduv4.y,
                             _uv12.x + tduv4.x, _uv12.y - tduv4.y,
                             _uv12.x + tduv4.x, _uv12.y + tduv4.y,
                             _uv12.x - tduv4.x, _uv12.y + tduv4.y,
                            "wrap", wrapmode, "filter", _filter4,
                            "width", _width4, "border", _border4,
                            "extrapolate", _extrapol4, "lerp", _interp4,
                            "channel", _channel5, "face", fptex,
                            "blur", _blur4, "pixelblur", _pixelblur4,
                            "srccolorspace", ocio == '' ? _srccolorspace4 : 'linear');
                } else {
                    clr10 = texture(_map_udim, _uv12.x, _uv12.y, "wrap", wrapmode,
                            "filter", _filter4, "width", _width4,
                            "border", _border4, "extrapolate", _extrapol4,
                            "channel", _channel5, "face", fptex,
                            "lerp", _interp4,
                            "blur", _blur4, "pixelblur", _pixelblur4,
                            "srccolorspace", ocio == '' ? _srccolorspace4 : 'linear');
                }
                if (ocio != '')
                    clr10 = ocio_transform(ocio, "scene_linear", clr10);
            }
        } else {
           clr10 = set(_defclr4);
        }



        clr9 = clr10;
    }


    lum3 = luminance(clr9);



    vector tnN1 = 1 ? outN : normalize(N);
    vector tanu = 0 ? vector() : normalize(dPds);





    vector f0 = { 1, 1, 1 };

    float index = lum3;

    float rx = clamp*clamp;
    float ry = rx;

    if(0!=0){
        {
            matrix3 rot = ident();

            rotate(rot, -3.1415926*(0+0.5), cross(cross(tanu, tnN1), tanu));
            tanu *= rot;
        }

        float aniso_value = 0*0*rx;
        rx += aniso_value;
        ry -= aniso_value;
    } else {
        matrix3 to_world = dihedral({0.0,0.0,1.0}, tnN1);
        tanu = {1,0,0} * to_world;
    }

    float top_layer_eta = 1.0/1;

    f1 = cvex_bsdf("mrp_ggx_eval", "mrp_ggx_sample",
                   "label", "reflect",
                   "bouncemasklabels", bouncemask("reflect"),
                   "nN", tnN1,
                   "fresnel0", f0,
                   "index", index,
                   "tangent", tanu,
                   "top_layer_eta", top_layer_eta,
                   "roughnessx", rx,
                   "roughnessy", ry);


    bool31 = (reflect_texture != "");


    found11 = renderstate("packed:ms_reflect", val11);
    if (!found11) val11 = "";


    bool32 = (val11 != "");


    bound_ms_reflect = isbound("ms_reflect");
#line 3612 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result80 = (0 != 0 ? (bound_ms_reflect != 0 ? reflect_texture : ms_reflect)
                                  : (bound_ms_reflect != 0 ? ms_reflect : reflect_texture));
#line 3627 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result81 = (0 != 0 ? (bool32 != 0 ? result80 : val11)
                                  : (bool32 != 0 ? val11 : result80));
#line 3642 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result82 = (0 != 0 ? (bool31 != 0 ? result81 : reflect_texture)
                                  : (bool31 != 0 ? reflect_texture : result81));




    bool33 = (result82 != "");


    vector	_uv13 = uv1;
    vector	_duv5 = vector();
    string	_map5 = result82;
    int	_udim6 = 1;
    string	_srccolorspace5 = "auto";
    string	_wrap5 = "repeat";
    string	_filter5 = "box";
    float	_width5 = 1;
    float	_blur5 = 0;
    float	_pixelblur5 = 0;
    vector4	_border5 = { 0, 0, 0, 1 };
    int	_extrapol5 = 1;
    int	_interp5 = 0;
    vector4	_defclr5 = { 0, 0, 0, 0 };
    string	_channel6 = "";
    int	_ptexface5 = 0;
    int	_orient5 = 0;
    vector	clr11 = vector();
    {


        string	_mode7 = "uv";
        vector	uv16 = vector();
        float	u7 = 0.0;
        float	v7 = 0.0;
        float	w7 = 0.0;
        {


            bool34 = (_mode7 == "st");


            bound_uv7 = isbound("uv");


            bound_st7 = isbound("st");



            uv17 = set(s, t, 0);





            output17 = st;


            if( bound_st7 == 0 )
                result83 = uv17;
            else
                result83 = output17;


            if( bound_uv7 == 0 )
                result84 = result83;
            else
                result84 = uv;


            if( bool34 == 0 )
                result85 = result84;
            else
                result85 = uv17;


            assign(fval114,fval214,fval314, result85);


            uv16 = result85;
            u7 = fval114;
            v7 = fval214;
            w7 = fval314;
        }


        result86 = 1 != 0 ? _uv13 : uv16;


        _uv14 = result86;


        if (_map5 != "") {

            int fptex = 0 ? _ptexface5 : getptextureid();



            string wrapmode = _wrap5;
            if (_orient5 & 0x02) { _uv14.y = 1 - _uv14.y; }
            if (_orient5 & 0x04) { float x = _uv14.x; _uv14.x = _uv14.y; _uv14.y = x; }
            string _map_udim = _map5;
            string ocio = ocio_parsecolorspace(_map5);
            if (_udim6 && has_udim(_map5))
                _map_udim = expand_udim(_uv14.x, _uv14.y, _map5);
            if (_map_udim == '') { clr12 = set(_defclr5); }
            else {
                if (_map_udim != _map5) {
                    _uv14.x %= 1.0; _uv14.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient5 & 0x01) { _uv14.x = 1 - _uv14.x; }
                if (0 != 0) {
                    vector tduv5 = 0.5 * _duv5;
                    if (_orient5 & 0x04) { float x = tduv5.x; tduv5.x = tduv5.y; tduv5.y = x; }
                    clr12 = texture(_map_udim,
                             _uv14.x - tduv5.x, _uv14.y - tduv5.y,
                             _uv14.x + tduv5.x, _uv14.y - tduv5.y,
                             _uv14.x + tduv5.x, _uv14.y + tduv5.y,
                             _uv14.x - tduv5.x, _uv14.y + tduv5.y,
                            "wrap", wrapmode, "filter", _filter5,
                            "width", _width5, "border", _border5,
                            "extrapolate", _extrapol5, "lerp", _interp5,
                            "channel", _channel6, "face", fptex,
                            "blur", _blur5, "pixelblur", _pixelblur5,
                            "srccolorspace", ocio == '' ? _srccolorspace5 : 'linear');
                } else {
                    clr12 = texture(_map_udim, _uv14.x, _uv14.y, "wrap", wrapmode,
                            "filter", _filter5, "width", _width5,
                            "border", _border5, "extrapolate", _extrapol5,
                            "channel", _channel6, "face", fptex,
                            "lerp", _interp5,
                            "blur", _blur5, "pixelblur", _pixelblur5,
                            "srccolorspace", ocio == '' ? _srccolorspace5 : 'linear');
                }
                if (ocio != '')
                    clr12 = ocio_transform(ocio, "scene_linear", clr12);
            }
        } else {
           clr12 = set(_defclr5);
        }



        clr11 = clr12;
    }


    clamp1 = clamp(clr11, { 0, 0, 0 }, { 1, 1, 1 });


    outcheck1 = bool33;
    outgloss = clamp1;

    _mat_megascans_shader_simple1_snippet5(outcheck1, outgloss);


    clamp2 = clamp(outgloss, { 0, 0, 0 }, { 1, 1, 1 });


    product11 = f1 * clamp2;


    vector	_uv15 = uv1;
    vector	_duv6 = vector();
    string	_map6 = result62;
    int	_udim7 = 1;
    string	_srccolorspace6 = "auto";
    string	_wrap6 = "repeat";
    string	_filter6 = "box";
    float	_width6 = 1;
    float	_blur6 = 0;
    float	_pixelblur6 = 0;
    vector4	_border6 = { 0, 0, 0, 1 };
    int	_extrapol6 = 1;
    int	_interp6 = 0;
    vector4	_defclr6 = { 0, 0, 0, 0 };
    string	_channel7 = "";
    int	_ptexface6 = 0;
    int	_orient6 = 0;
    vector	clr13 = vector();
    {


        string	_mode8 = "uv";
        vector	uv18 = vector();
        float	u8 = 0.0;
        float	v8 = 0.0;
        float	w8 = 0.0;
        {


            bool35 = (_mode8 == "st");


            bound_uv8 = isbound("uv");


            bound_st8 = isbound("st");



            uv19 = set(s, t, 0);





            output18 = st;


            if( bound_st8 == 0 )
                result87 = uv19;
            else
                result87 = output18;


            if( bound_uv8 == 0 )
                result88 = result87;
            else
                result88 = uv;


            if( bool35 == 0 )
                result89 = result88;
            else
                result89 = uv19;


            assign(fval115,fval215,fval315, result89);


            uv18 = result89;
            u8 = fval115;
            v8 = fval215;
            w8 = fval315;
        }


        result90 = 1 != 0 ? _uv15 : uv18;


        _uv16 = result90;


        if (_map6 != "") {

            int fptex = 0 ? _ptexface6 : getptextureid();



            string wrapmode = _wrap6;
            if (_orient6 & 0x02) { _uv16.y = 1 - _uv16.y; }
            if (_orient6 & 0x04) { float x = _uv16.x; _uv16.x = _uv16.y; _uv16.y = x; }
            string _map_udim = _map6;
            string ocio = ocio_parsecolorspace(_map6);
            if (_udim7 && has_udim(_map6))
                _map_udim = expand_udim(_uv16.x, _uv16.y, _map6);
            if (_map_udim == '') { clr14 = set(_defclr6); }
            else {
                if (_map_udim != _map6) {
                    _uv16.x %= 1.0; _uv16.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient6 & 0x01) { _uv16.x = 1 - _uv16.x; }
                if (0 != 0) {
                    vector tduv6 = 0.5 * _duv6;
                    if (_orient6 & 0x04) { float x = tduv6.x; tduv6.x = tduv6.y; tduv6.y = x; }
                    clr14 = texture(_map_udim,
                             _uv16.x - tduv6.x, _uv16.y - tduv6.y,
                             _uv16.x + tduv6.x, _uv16.y - tduv6.y,
                             _uv16.x + tduv6.x, _uv16.y + tduv6.y,
                             _uv16.x - tduv6.x, _uv16.y + tduv6.y,
                            "wrap", wrapmode, "filter", _filter6,
                            "width", _width6, "border", _border6,
                            "extrapolate", _extrapol6, "lerp", _interp6,
                            "channel", _channel7, "face", fptex,
                            "blur", _blur6, "pixelblur", _pixelblur6,
                            "srccolorspace", ocio == '' ? _srccolorspace6 : 'linear');
                } else {
                    clr14 = texture(_map_udim, _uv16.x, _uv16.y, "wrap", wrapmode,
                            "filter", _filter6, "width", _width6,
                            "border", _border6, "extrapolate", _extrapol6,
                            "channel", _channel7, "face", fptex,
                            "lerp", _interp6,
                            "blur", _blur6, "pixelblur", _pixelblur6,
                            "srccolorspace", ocio == '' ? _srccolorspace6 : 'linear');
                }
                if (ocio != '')
                    clr14 = ocio_transform(ocio, "scene_linear", clr14);
            }
        } else {
           clr14 = set(_defclr6);
        }



        clr13 = clr14;
    }



    vector tnN2 = 1 ? nvec5 : normalize(N);
    vector tanu1 = 0 ? vector() : normalize(dPds);





    vector m_refl = clr13;
    vector m_tint = { 0.99851800000000002, 0.97072000000000003, 0.77651899999999996 };
    if(0>0){
        m_refl = fresnelcond_reflectivity({ 0.15557000000000001, 0.52329000000000003, 1.3319000000000001 }, { 3.6023999999999998, 2.2713999999999999, 1.8693 });
        m_tint = fresnelcond_edgetint({ 0.15557000000000001, 0.52329000000000003, 1.3319000000000001 }, m_refl);
    }
    m_refl = min(m_refl,0.9999);

    float rx1 = clamp*clamp;
    float ry1 = rx1;

    if(0!=0){
        {
            matrix3 rot1 = ident();
            rotate(rot1, radians(0), cross(cross(tanu1, tnN2), tanu1));
            tanu1 *= rot1;
        }

        if (0 < 0.0)
            ry1 *= (1.0+0)*(1.0+0);
        else
            rx1 *= (1.0-(0))*(1.0-(0));
    } else {
        matrix3 to_world = dihedral({0.0,0.0,1.0}, tnN2);
        tanu1 = {1,0,0} * to_world;
    }

    f2 = cvex_bsdf("mrp_ggx_eval", "mrp_ggx_sample",
                   "label", "reflect",
                   "bouncemasklabels", bouncemask("reflect"),
                   "nN", tnN2,
                   "reflectivity", m_refl,
                   "edgetint", m_tint,
                   "metallic", 1,
                   "tangent", tanu1,
                   "roughnessx", rx1,
                   "roughnessy", ry1);


    sum5 = product11 + f2;







        float scale38 = (0 != 0 ? (bool22 != 0 ? 1 : 0)
                                       : (bool22 != 0 ? 0 : 1));
        result91 = (1-scale38)*sum5 + scale38*product11;







    shift3 = fit(rand, 0, 1, 0.90000000000000002, 1);


    product12 = result91 * shift3;







        float scale39 = (0 != 0 ? (found5 != 0 ? 1 : 0)
                                       : (found5 != 0 ? 0 : 1));
        result92 = (1-scale39)*result91 + scale39*product12;







    bool36 = (reflect_scale != 1);


    found12 = renderstate("packed:ms_reflectscale", val12);
    if (!found12) val12 = 0;


    bound_ms_reflectscale = isbound("ms_reflectscale");
#line 4047 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result93 = (0 != 0 ? (bound_ms_reflectscale != 0 ? reflect_scale : ms_reflectscale)
                                  : (bound_ms_reflectscale != 0 ? ms_reflectscale : reflect_scale));
#line 4062 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result94 = (0 != 0 ? (found12 != 0 ? result93 : val12)
                                  : (found12 != 0 ? val12 : result93));
#line 4077 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result95 = (0 != 0 ? (bool36 != 0 ? result94 : reflect_scale)
                                  : (bool36 != 0 ? reflect_scale : result94));




    product13 = result92 * result95;


    outcheck2 = outval12;
    outsurface1 = f;
    outreflect = product13;

    _mat_megascans_shader_simple1_snippet3(outcheck2, outsurface1, outreflect);


    if (0 == 0)
        f3 = isotropic("label", "");
    else
        f3 = henyeygreenstein(0, "label", "");


    vector	_uv17 = uv1;
    vector	_duv7 = vector();
    string	_map7 = result16;
    int	_udim8 = 1;
    string	_srccolorspace7 = "auto";
    string	_wrap7 = "repeat";
    string	_filter7 = "box";
    float	_width7 = 1;
    float	_blur7 = 0;
    float	_pixelblur7 = 0;
    vector4	_border7 = { 0, 0, 0, 1 };
    int	_extrapol7 = 1;
    int	_interp7 = 0;
    vector4	_defclr7 = { 0, 0, 0, 0 };
    string	_channel8 = "";
    int	_ptexface7 = 0;
    int	_orient7 = 0;
    vector	clr15 = vector();
    {


        string	_mode9 = "uv";
        vector	uv20 = vector();
        float	u9 = 0.0;
        float	v9 = 0.0;
        float	w9 = 0.0;
        {


            bool37 = (_mode9 == "st");


            bound_uv9 = isbound("uv");


            bound_st9 = isbound("st");



            uv21 = set(s, t, 0);





            output19 = st;


            if( bound_st9 == 0 )
                result96 = uv21;
            else
                result96 = output19;


            if( bound_uv9 == 0 )
                result97 = result96;
            else
                result97 = uv;


            if( bool37 == 0 )
                result98 = result97;
            else
                result98 = uv21;


            assign(fval116,fval216,fval316, result98);


            uv20 = result98;
            u9 = fval116;
            v9 = fval216;
            w9 = fval316;
        }


        result99 = 1 != 0 ? _uv17 : uv20;


        _uv18 = result99;


        if (_map7 != "") {

            int fptex = 0 ? _ptexface7 : getptextureid();



            string wrapmode = _wrap7;
            if (_orient7 & 0x02) { _uv18.y = 1 - _uv18.y; }
            if (_orient7 & 0x04) { float x = _uv18.x; _uv18.x = _uv18.y; _uv18.y = x; }
            string _map_udim = _map7;
            string ocio = ocio_parsecolorspace(_map7);
            if (_udim8 && has_udim(_map7))
                _map_udim = expand_udim(_uv18.x, _uv18.y, _map7);
            if (_map_udim == '') { clr16 = set(_defclr7); }
            else {
                if (_map_udim != _map7) {
                    _uv18.x %= 1.0; _uv18.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient7 & 0x01) { _uv18.x = 1 - _uv18.x; }
                if (0 != 0) {
                    vector tduv7 = 0.5 * _duv7;
                    if (_orient7 & 0x04) { float x = tduv7.x; tduv7.x = tduv7.y; tduv7.y = x; }
                    clr16 = texture(_map_udim,
                             _uv18.x - tduv7.x, _uv18.y - tduv7.y,
                             _uv18.x + tduv7.x, _uv18.y - tduv7.y,
                             _uv18.x + tduv7.x, _uv18.y + tduv7.y,
                             _uv18.x - tduv7.x, _uv18.y + tduv7.y,
                            "wrap", wrapmode, "filter", _filter7,
                            "width", _width7, "border", _border7,
                            "extrapolate", _extrapol7, "lerp", _interp7,
                            "channel", _channel8, "face", fptex,
                            "blur", _blur7, "pixelblur", _pixelblur7,
                            "srccolorspace", ocio == '' ? _srccolorspace7 : 'linear');
                } else {
                    clr16 = texture(_map_udim, _uv18.x, _uv18.y, "wrap", wrapmode,
                            "filter", _filter7, "width", _width7,
                            "border", _border7, "extrapolate", _extrapol7,
                            "channel", _channel8, "face", fptex,
                            "lerp", _interp7,
                            "blur", _blur7, "pixelblur", _pixelblur7,
                            "srccolorspace", ocio == '' ? _srccolorspace7 : 'linear');
                }
                if (ocio != '')
                    clr16 = ocio_transform(ocio, "scene_linear", clr16);
            }
        } else {
           clr16 = set(_defclr7);
        }



        clr15 = clr16;
    }


    vector	_clr1 = clr15;
    {


        to1 = ocio_transform("Utility - Linear - sRGB", "acescg", _clr1);


        if( 1 == 0 )
            result100 = _clr1;
        else
            result100 = to1;


        if( 1 == 0 )
            result101 = _clr1;
        else
            result101 = result100;


        _clr1 = result101;
    }


    shift4 = fit(rand1, { 0, 0, 0 }, { 1, 1, 1 }, { 0.45000000000000001, 0.45000000000000001, 0.45000000000000001 }, { 0.55000000000000004, 0.55000000000000004, 0.55000000000000004 });


    Value5 = { 0.5, 0.5, 0.5 };
#line 4275 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result102 = (0 != 0 ? (val5 != 0 ? Value5 : shift4)
                                  : (val5 != 0 ? shift4 : Value5));




    vector	_ClrIn2 = _clr1;
    float	_Shift2 = 0;
    float	_Saturation2 = 0.69999999999999996;
    float	_Value2 = 1;
    vector	_Bias2 = { 0.5, 0.5, 0.5 };
    vector	_Gain2 = result102;
    float	_Gamma2 = 1;
    vector	ClrOut2 = vector();
    {


        hsv2 = rgbtohsv(_ClrIn2);


        assign(fval117,fval217,fval317, hsv2);


        fraction4 = frac(_Shift2);


        sum6 = fval117 + fraction4;


        fraction5 = frac(sum6);


        product14 = fval217 * _Saturation2;


        product15 = fval317 * _Value2;


        vec2 = set(fraction5,product14,product15);


        rgb2 = hsvtorgb(vec2);
#line 4328 "/mat/megascans_shader_simple1/SurfaceVexCode"
           float cr4 = vop_bias(rgb2.x, _Bias2.x);
           float cg4 = vop_bias(rgb2.y, _Bias2.y);
           float cb4 = vop_bias(rgb2.z, _Bias2.z);
           bias2 = set(cr4, cg4, cb4);
#line 4353 "/mat/megascans_shader_simple1/SurfaceVexCode"
           float cr5 = vop_gain(bias2.x, _Gain2.x);
           float cg5 = vop_gain(bias2.y, _Gain2.y);
           float cb5 = vop_gain(bias2.z, _Gain2.z);
           gain2 = set(cr5, cg5, cb5);
#line 4369 "/mat/megascans_shader_simple1/SurfaceVexCode"
          inverse2 = 1.0 / _Gamma2;





        pow2 = pow((gain2), inverse2);


        ClrOut2 = pow2;
    }


    vector	_ClrOut = ClrOut2;
    int	_bool = bool6;
    float	Value6 = 0.0;
    {


        vector	_ClrIn3 = _ClrOut;
        float	_Shift3 = Shift;
        float	_Saturation3 = Saturation;
        float	_Value3 = Value;
        vector	_Bias3 = Bias;
        vector	_Gain3 = Gain;
        float	_Gamma3 = Gamma;
        vector	ClrOut3 = vector();
        {


            hsv3 = rgbtohsv(_ClrIn3);


            assign(fval118,fval218,fval318, hsv3);


            fraction6 = frac(_Shift3);


            sum7 = fval118 + fraction6;


            fraction7 = frac(sum7);


            product16 = fval218 * _Saturation3;


            product17 = fval318 * _Value3;


            vec3 = set(fraction7,product16,product17);


            rgb3 = hsvtorgb(vec3);
#line 4435 "/mat/megascans_shader_simple1/SurfaceVexCode"
               float cr6 = vop_bias(rgb3.x, _Bias3.x);
               float cg6 = vop_bias(rgb3.y, _Bias3.y);
               float cb6 = vop_bias(rgb3.z, _Bias3.z);
               bias3 = set(cr6, cg6, cb6);
#line 4460 "/mat/megascans_shader_simple1/SurfaceVexCode"
               float cr7 = vop_gain(bias3.x, _Gain3.x);
               float cg7 = vop_gain(bias3.y, _Gain3.y);
               float cb7 = vop_gain(bias3.z, _Gain3.z);
               gain3 = set(cr7, cg7, cb7);
#line 4476 "/mat/megascans_shader_simple1/SurfaceVexCode"
              inverse3 = 1.0 / _Gamma3;





            pow3 = pow((gain3), inverse3);


            ClrOut3 = pow3;
        }


        if( _bool == 0 )
            result103 = _ClrOut;
        else
            result103 = ClrOut3;


        _ClrOut = result103;
        Value6 = Value;
    }


    Value7 = 0.20000000000000001;


    product18 = f3 * _ClrOut * Value7;


    outcheck3 = bool6;
    outsurface2 = outsurface1;
    outtrans = product18;

    _mat_megascans_shader_simple1_snippet1(outcheck3, outsurface2, outtrans);


    bsdf	_f = outsurface2;
    float	scale44 = 0.0;

    {


        int components = 0;
        if (1)
            components |= bouncemask("alldiffuse");
        if (1)
            components |= (bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss")));
        if (0)
            components |= bouncemask("allvolume");

        vector ii = (0 != 0) ? vector() : normalize(I);
        albedo = albedo(_f, -ii, components);


        lum4 = luminance(albedo);


        eps = 9.9999999999999995e-07;


        max = max( lum4 , eps );



          inverse4 = 1.0 / max;





        input2 = 1;


        min = min( inverse4 , input2 );


        product19 = _f * min;


        scale45 = min;


        _f = product19;
        scale44 = scale45;
    }


    ShaderLayer	_layer = {};
    bsdf	_F = _f;
    vector	_nN = vector();
    vector	_gain = { 1, 1, 1 };
    int	_bounce = 0;
    ShaderLayer	__layer = {};
    bsdf	__F = bsdf();
    {


        {
            int tmp_level = 0;
            if (rayimport('level', tmp_level)) tmp_level += 1;
            raylevel = max(getraylevel(), tmp_level);
        }


        bool38 = (raylevel > _bounce);


        connected1 = 0;


        vector myI = 0 != 0 ? vector() : I;
        vector myN1 = 0 != 0 ? vector() : N;
        frontN = frontface(myN1, myI);
        if (1)
            frontN = normalize(frontN);


        nvec6 = normalize(frontN);


        init_layer(layer2);

        layer2.F = select(1, _F, layer2.F);
        layer2.Of = select(0, vector(), layer2.Of);
        layer2.Ce = select(0, vector(), layer2.Ce);
        layer2.P = select(0, vector(), layer2.P);
        layer2.N = select(1, nvec6, layer2.N);
        layer2.masks = select(0, {}, layer2.masks);


        if( connected1 == 0 )
            result104 = layer2;
        else
            result104 = _layer;


        ShaderLayer	_layer1 = result104;
        bsdf	F1 = bsdf();
        vector	Of1 = vector();
        vector	Ce = vector();
        vector	P1 = vector();
        vector	N1 = vector();
        float	layeralpha = 0.0;
        float	masks[] = {};
        {


            out_struct = _layer1;
            out_F = out_struct.F;
            out_Of = out_struct.Of;
            out_Ce = out_struct.Ce;
            out_P = out_struct.P;
            out_N = out_struct.N;
            out_layeralpha = out_struct.layeralpha;
            out_masks = out_struct.masks;


            F1 = out_F;
            Of1 = out_Of;
            Ce = out_Ce;
            P1 = out_P;
            N1 = out_N;
            layeralpha = out_layeralpha;
            masks = out_masks;
        }


        result105 = 1 != 0 ? _F : F1;


        if( connected1 == 0 )
            result106 = nvec6;
        else
            result106 = N1;


        result107 = 0 != 0 ? _nN : result106;


        condition_out = bool38;
        var1_out = result105;
        var2_out = result107;
        var3_out = _gain;
        if (condition_out)
        {


            int components1 = 0;
            if (1)
                components1 |= bouncemask("alldiffuse");
            if (1)
                components1 |= (bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss")));
            if (0)
                components1 |= bouncemask("allvolume");

            vector ii1 = (0 != 0) ? vector() : normalize(I);
            albedo1 = albedo(var1_out, -ii1, components1);



            vector tnN3 = 1 ? var2_out : normalize(N);
            vector tnNg1 = dot(tnN3, Ng) > 0 ? Ng : -Ng;





            if(1)
            {
                tnN3 = frontface(tnN3, I);
                tnNg1 = frontface(tnNg1, I);
            }

            if ("diffuse" != "translucent")
            {
                if (0 > 0)
                    f4 = 2.0*diffuse(tnN3, tnNg1, 0, "label", "");
                else
                    f4 = 2.0*diffuse(tnN3, tnNg1, "label", "");
            }
            else
            {
                f4 = 2.0*translucent(tnN3, tnNg1, "label", "");
            }

            init_layer(layer3);
            f4 *= albedo1;
            layer3.F = f4;


            product20 = f4 * var3_out;


            var1_out = product20;
        }


        init_layer(layer4);

        layer4.F = select(1, var1_out, layer4.F);
        layer4.Of = select(1, Of1, layer4.Of);
        layer4.Ce = select(1, Ce, layer4.Ce);
        layer4.P = select(1, P1, layer4.P);
        layer4.N = select(1, N1, layer4.N);
        layer4.masks = select(0, {}, layer4.masks);


        __layer = layer4;
        __F = var1_out;
    }


    if( simplify_bsdf == 0 )
        result108 = _f;
    else
        result108 = __F;


    ms_occlusion = shift2;


    lum5 = luminance(outsurface);


    layer_mask = lum5;


    init_layer(layer5);

    layer5.F = select(1, result108, layer5.F);
    layer5.Of = select(1, result13, layer5.Of);
    layer5.Ce = select(0, vector(), layer5.Ce);
    layer5.P = select(0, vector(), layer5.P);
    layer5.N = select(0, vector(), layer5.N);
    layer5.masks = select(0, {}, layer5.masks);


    len1 = length(clr13);


    product21 = clamp2 * result95;


    product22 = _ClrOut * Value7;


    export_uv1 = uv1;


    bound_addative_displace = isbound("addative_displace");


    bool39 = (disp_texture != "");


    found13 = renderstate("packed:ms_displace", val13);
    if (!found13) val13 = "";


    bound_ms_displace = isbound("ms_displace");
#line 4788 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result109 = (0 != 0 ? (bound_ms_displace != 0 ? disp_texture : ms_displace)
                                  : (bound_ms_displace != 0 ? ms_displace : disp_texture));
#line 4803 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result110 = (0 != 0 ? (found13 != 0 ? result109 : val13)
                                  : (found13 != 0 ? val13 : result109));
#line 4818 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result111 = (0 != 0 ? (bool39 != 0 ? result110 : disp_texture)
                                  : (bool39 != 0 ? disp_texture : result110));




    bool40 = (result111 != "");


    vector	_uv19 = uv1;
    vector	_duv8 = vector();
    string	_map8 = result111;
    int	_udim9 = 1;
    string	_srccolorspace8 = "auto";
    string	_wrap8 = "repeat";
    string	_filter8 = "box";
    float	_width8 = 1;
    float	_blur8 = 0;
    float	_pixelblur8 = 0;
    vector4	_border8 = { 0, 0, 0, 1 };
    int	_extrapol8 = 1;
    int	_interp8 = 0;
    vector4	_defclr8 = { 0, 0, 0, 0 };
    string	_channel9 = "";
    int	_ptexface8 = 0;
    int	_orient8 = 0;
    vector	clr17 = vector();
    {


        string	_mode10 = "uv";
        vector	uv22 = vector();
        float	u10 = 0.0;
        float	v10 = 0.0;
        float	w10 = 0.0;
        {


            bool41 = (_mode10 == "st");


            bound_uv10 = isbound("uv");


            bound_st10 = isbound("st");



            uv23 = set(s, t, 0);





            output110 = st;


            if( bound_st10 == 0 )
                result112 = uv23;
            else
                result112 = output110;


            if( bound_uv10 == 0 )
                result113 = result112;
            else
                result113 = uv;


            if( bool41 == 0 )
                result114 = result113;
            else
                result114 = uv23;


            assign(fval119,fval219,fval319, result114);


            uv22 = result114;
            u10 = fval119;
            v10 = fval219;
            w10 = fval319;
        }


        result115 = 1 != 0 ? _uv19 : uv22;


        _uv20 = result115;


        if (_map8 != "") {

            int fptex = 0 ? _ptexface8 : getptextureid();



            string wrapmode = _wrap8;
            if (_orient8 & 0x02) { _uv20.y = 1 - _uv20.y; }
            if (_orient8 & 0x04) { float x = _uv20.x; _uv20.x = _uv20.y; _uv20.y = x; }
            string _map_udim = _map8;
            string ocio = ocio_parsecolorspace(_map8);
            if (_udim9 && has_udim(_map8))
                _map_udim = expand_udim(_uv20.x, _uv20.y, _map8);
            if (_map_udim == '') { clr18 = set(_defclr8); }
            else {
                if (_map_udim != _map8) {
                    _uv20.x %= 1.0; _uv20.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient8 & 0x01) { _uv20.x = 1 - _uv20.x; }
                if (0 != 0) {
                    vector tduv8 = 0.5 * _duv8;
                    if (_orient8 & 0x04) { float x = tduv8.x; tduv8.x = tduv8.y; tduv8.y = x; }
                    clr18 = texture(_map_udim,
                             _uv20.x - tduv8.x, _uv20.y - tduv8.y,
                             _uv20.x + tduv8.x, _uv20.y - tduv8.y,
                             _uv20.x + tduv8.x, _uv20.y + tduv8.y,
                             _uv20.x - tduv8.x, _uv20.y + tduv8.y,
                            "wrap", wrapmode, "filter", _filter8,
                            "width", _width8, "border", _border8,
                            "extrapolate", _extrapol8, "lerp", _interp8,
                            "channel", _channel9, "face", fptex,
                            "blur", _blur8, "pixelblur", _pixelblur8,
                            "srccolorspace", ocio == '' ? _srccolorspace8 : 'linear');
                } else {
                    clr18 = texture(_map_udim, _uv20.x, _uv20.y, "wrap", wrapmode,
                            "filter", _filter8, "width", _width8,
                            "border", _border8, "extrapolate", _extrapol8,
                            "channel", _channel9, "face", fptex,
                            "lerp", _interp8,
                            "blur", _blur8, "pixelblur", _pixelblur8,
                            "srccolorspace", ocio == '' ? _srccolorspace8 : 'linear');
                }
                if (ocio != '')
                    clr18 = ocio_transform(ocio, "scene_linear", clr18);
            }
        } else {
           clr18 = set(_defclr8);
        }



        clr17 = clr18;
    }


    lum6 = luminance(clr17);


    diff2 = lum6 - dispoffset;


    Value8 = 0;


    outcheck4 = bool40;
    outval14 = diff2;
    outval24 = Value8;

    _mat_megascans_shader_simple1_snippet8(outcheck4, outval14, outval24);


    Value9 = 1;


    bool42 = (dispTex_scale != 1);


    found14 = renderstate("packed:ms_dscale", val14);
    if (!found14) val14 = 0;


    bound_ms_dscale = isbound("ms_dscale");
#line 5003 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result116 = (0 != 0 ? (bound_ms_dscale != 0 ? dispTex_scale : ms_dscale)
                                  : (bound_ms_dscale != 0 ? ms_dscale : dispTex_scale));
#line 5018 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result117 = (0 != 0 ? (found14 != 0 ? result116 : val14)
                                  : (found14 != 0 ? val14 : result116));
#line 5033 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result118 = (0 != 0 ? (bool42 != 0 ? result117 : dispTex_scale)
                                  : (bool42 != 0 ? dispTex_scale : result117));




    product23 = Value9 * result118;


    product24 = outval14 * product23;


    sum8 = product24 + addative_displace;
#line 5057 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result119 = (0 != 0 ? (bound_addative_displace != 0 ? product24 : sum8)
                                  : (bound_addative_displace != 0 ? sum8 : product24));




    len2 = length(result13);


    product25 = result119 * len2;


    if( dmultopacity == 0 )
        result120 = result119;
    else
        result120 = product25;


    vec4 = set(result120,result120,result120);


    vector	_uv21 = uv1;
    vector	_duv9 = vector();
    string	_map9 = result38;
    int	_udim10 = 1;
    string	_srccolorspace9 = "linear";
    string	_wrap9 = "repeat";
    string	_filter9 = "gauss";
    float	_width9 = 1;
    float	_blur9 = 0;
    float	_pixelblur9 = 0;
    vector4	_border9 = { 0, 0, 0, 1 };
    int	_extrapol9 = 1;
    int	_interp9 = 0;
    vector4	_defclr9 = { 0, 0, 0, 0 };
    string	_channel10 = "";
    int	_ptexface9 = 0;
    int	_orient9 = 0;
    vector	clr19 = vector();
    {


        string	_mode11 = "uv";
        vector	uv24 = vector();
        float	u11 = 0.0;
        float	v11 = 0.0;
        float	w11 = 0.0;
        {


            bool43 = (_mode11 == "st");


            bound_uv11 = isbound("uv");


            bound_st11 = isbound("st");



            uv25 = set(s, t, 0);





            output111 = st;


            if( bound_st11 == 0 )
                result121 = uv25;
            else
                result121 = output111;


            if( bound_uv11 == 0 )
                result122 = result121;
            else
                result122 = uv;


            if( bool43 == 0 )
                result123 = result122;
            else
                result123 = uv25;


            assign(fval120,fval220,fval320, result123);


            uv24 = result123;
            u11 = fval120;
            v11 = fval220;
            w11 = fval320;
        }


        result124 = 1 != 0 ? _uv21 : uv24;


        _uv22 = result124;


        if (_map9 != "") {

            int fptex = 0 ? _ptexface9 : getptextureid();



            string wrapmode = _wrap9;
            if (_orient9 & 0x02) { _uv22.y = 1 - _uv22.y; }
            if (_orient9 & 0x04) { float x = _uv22.x; _uv22.x = _uv22.y; _uv22.y = x; }
            string _map_udim = _map9;
            string ocio = ocio_parsecolorspace(_map9);
            if (_udim10 && has_udim(_map9))
                _map_udim = expand_udim(_uv22.x, _uv22.y, _map9);
            if (_map_udim == '') { clr20 = set(_defclr9); }
            else {
                if (_map_udim != _map9) {
                    _uv22.x %= 1.0; _uv22.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient9 & 0x01) { _uv22.x = 1 - _uv22.x; }
                if (0 != 0) {
                    vector tduv9 = 0.5 * _duv9;
                    if (_orient9 & 0x04) { float x = tduv9.x; tduv9.x = tduv9.y; tduv9.y = x; }
                    clr20 = texture(_map_udim,
                             _uv22.x - tduv9.x, _uv22.y - tduv9.y,
                             _uv22.x + tduv9.x, _uv22.y - tduv9.y,
                             _uv22.x + tduv9.x, _uv22.y + tduv9.y,
                             _uv22.x - tduv9.x, _uv22.y + tduv9.y,
                            "wrap", wrapmode, "filter", _filter9,
                            "width", _width9, "border", _border9,
                            "extrapolate", _extrapol9, "lerp", _interp9,
                            "channel", _channel10, "face", fptex,
                            "blur", _blur9, "pixelblur", _pixelblur9,
                            "srccolorspace", ocio == '' ? _srccolorspace9 : 'linear');
                } else {
                    clr20 = texture(_map_udim, _uv22.x, _uv22.y, "wrap", wrapmode,
                            "filter", _filter9, "width", _width9,
                            "border", _border9, "extrapolate", _extrapol9,
                            "channel", _channel10, "face", fptex,
                            "lerp", _interp9,
                            "blur", _blur9, "pixelblur", _pixelblur9,
                            "srccolorspace", ocio == '' ? _srccolorspace9 : 'linear');
                }
                if (ocio != '')
                    clr20 = ocio_transform(ocio, "scene_linear", clr20);
            }
        } else {
           clr20 = set(_defclr9);
        }



        clr19 = clr20;
    }


    bool44 = (bump_texture != "");


    found15 = renderstate("packed:ms_bump", val15);
    if (!found15) val15 = "";


    bool45 = (val15 != "");


    bound_ms_bump = isbound("ms_bump");
#line 5238 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result125 = (0 != 0 ? (bound_ms_bump != 0 ? bump_texture : ms_bump)
                                  : (bound_ms_bump != 0 ? ms_bump : bump_texture));
#line 5253 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result126 = (0 != 0 ? (bool45 != 0 ? result125 : val15)
                                  : (bool45 != 0 ? val15 : result125));
#line 5268 "/mat/megascans_shader_simple1/SurfaceVexCode"
        result127 = (0 != 0 ? (bool44 != 0 ? result126 : bump_texture)
                                  : (bool44 != 0 ? bump_texture : result126));




    vector	_uv23 = vector();
    vector	_duv10 = vector();
    string	_map10 = result127;
    int	_udim11 = 1;
    string	_srccolorspace10 = "auto";
    string	_wrap10 = "repeat";
    string	_filter10 = "box";
    float	_width10 = 1;
    float	_blur10 = 0;
    float	_pixelblur10 = 0;
    vector4	_border10 = { 0, 0, 0, 1 };
    int	_extrapol10 = 1;
    int	_interp10 = 0;
    vector4	_defclr10 = { 0, 0, 0, 0 };
    string	_channel11 = "";
    int	_ptexface10 = 0;
    int	_orient10 = 0;
    vector	clr21 = vector();
    {


        string	_mode12 = "uv";
        vector	uv26 = vector();
        float	u12 = 0.0;
        float	v12 = 0.0;
        float	w12 = 0.0;
        {


            bool46 = (_mode12 == "st");


            bound_uv12 = isbound("uv");


            bound_st12 = isbound("st");



            uv27 = set(s, t, 0);





            output112 = st;


            if( bound_st12 == 0 )
                result128 = uv27;
            else
                result128 = output112;


            if( bound_uv12 == 0 )
                result129 = result128;
            else
                result129 = uv;


            if( bool46 == 0 )
                result130 = result129;
            else
                result130 = uv27;


            assign(fval121,fval221,fval321, result130);


            uv26 = result130;
            u12 = fval121;
            v12 = fval221;
            w12 = fval321;
        }


        result131 = 0 != 0 ? _uv23 : uv26;


        _uv24 = result131;


        if (_map10 != "") {

            int fptex = 0 ? _ptexface10 : getptextureid();



            string wrapmode = _wrap10;
            if (_orient10 & 0x02) { _uv24.y = 1 - _uv24.y; }
            if (_orient10 & 0x04) { float x = _uv24.x; _uv24.x = _uv24.y; _uv24.y = x; }
            string _map_udim = _map10;
            string ocio = ocio_parsecolorspace(_map10);
            if (_udim11 && has_udim(_map10))
                _map_udim = expand_udim(_uv24.x, _uv24.y, _map10);
            if (_map_udim == '') { clr22 = set(_defclr10); }
            else {
                if (_map_udim != _map10) {
                    _uv24.x %= 1.0; _uv24.y %= 1.0;
                    wrapmode = 'streak';
                }
                if (_orient10 & 0x01) { _uv24.x = 1 - _uv24.x; }
                if (0 != 0) {
                    vector tduv10 = 0.5 * _duv10;
                    if (_orient10 & 0x04) { float x = tduv10.x; tduv10.x = tduv10.y; tduv10.y = x; }
                    clr22 = texture(_map_udim,
                             _uv24.x - tduv10.x, _uv24.y - tduv10.y,
                             _uv24.x + tduv10.x, _uv24.y - tduv10.y,
                             _uv24.x + tduv10.x, _uv24.y + tduv10.y,
                             _uv24.x - tduv10.x, _uv24.y + tduv10.y,
                            "wrap", wrapmode, "filter", _filter10,
                            "width", _width10, "border", _border10,
                            "extrapolate", _extrapol10, "lerp", _interp10,
                            "channel", _channel11, "face", fptex,
                            "blur", _blur10, "pixelblur", _pixelblur10,
                            "srccolorspace", ocio == '' ? _srccolorspace10 : 'linear');
                } else {
                    clr22 = texture(_map_udim, _uv24.x, _uv24.y, "wrap", wrapmode,
                            "filter", _filter10, "width", _width10,
                            "border", _border10, "extrapolate", _extrapol10,
                            "channel", _channel11, "face", fptex,
                            "lerp", _interp10,
                            "blur", _blur10, "pixelblur", _pixelblur10,
                            "srccolorspace", ocio == '' ? _srccolorspace10 : 'linear');
                }
                if (ocio != '')
                    clr22 = ocio_transform(ocio, "scene_linear", clr22);
            }
        } else {
           clr22 = set(_defclr10);
        }



        clr21 = clr22;
    }


    ShaderLayer	_layer2 = layer5;
    vector	_export_diffcolor = _result;
    float	_export_rough = clamp;
    vector	_export_ior = clr9;
    float	_export_metallness = len1;
    vector	_export_speccolor = product21;
    vector	_export_translucency = product22;
    vector	_export_sss = { 0, 0, 0 };
    vector	_export_emission = { 0, 0, 0 };
    float	_export_mask = 0;
    float	_export_fuzz = 0;
    vector	_uv25 = export_uv1;
    vector	_N3 = nvec5;
    vector	_export_dispcolor = vec4;
    vector	_export_normal = clr19;
    vector	_export_bump = clr21;
    vector	_export_ao = clr4;
    vector	_export_opacity = result13;
    {


        isuvrender = isuvrendering();

        if (isuvrender)
        {
            renderstate("renderer:uvcurrentuvobject", uvobject);
            renderstate("renderer:uvcurrenthiresobject", uvhiresobject);
        }


        found16 = renderstate("global:uv_unwrap_method", val16);
        if (!found16) val16 = 0;


        unwrapmethod = val16;


        found17 = renderstate("global:uv_flip_normal", val17);
        if (!found17) val17 = 0;


        flipnormal = val17;


        Ds1 = 0;


        vector ref_P = 0;
        vector ref_N = 0;
        int found_P = dimport("pre_disp_P", ref_P);
        int found_N = dimport("pre_disp_N", ref_N);

        if (isuvrender && uvhiresobject != "")
        {
            vector ray_org_l = 0;
            if (getsamplestore("uvlens_ray_org_l", Eye, ray_org_l))
            {
                Ds1 = dot(normalize(I), ray_org_l-P);
                Ds1 *= select(unwrapmethod == 0 && flipnormal, -1, 1);
            }
            else
                Ds1 = length(I) * (dot(normalize(I), normalize(N)) < 0 ? 1.0 : -1.0);
        }
        else if (found_P && found_N)
        {

            vector pd = ref_P - P;
            float sgn = (dot(ref_N, normalize(pd)) > 0) ? -1 : 1;
            Ds1 = length(pd) * sgn;
        }




        result132 = 1 != 0 ? _export_dispcolor : Ds1;


        export_dispcolor = result132;


        found18 = renderstate("global:bake_usemikkt", val18);
        if (!found18) val18 = 0;


        usemikkt = val18;


        found19 = renderstate("global:bake_tangentnormalflipx", val19);
        if (!found19) val19 = 0;


        ntflipx = val19;


        found20 = renderstate("global:bake_tangentnormalflipy", val20);
        if (!found20) val20 = 0;


        ntflipy = val20;


        found21 = renderstate("global:bake_tangentnormalincludedisp", val21);
        if (!found21) val21 = 1;


        ntincludedisp = val21;


        nvec7 = normalize(N);


        result133 = 1 != 0 ? _N3 : nvec7;


        _N4 = result133;


        string	_tstyle1 = "uv";
        vector	_uv26 = vector();
        vector	_N5 = _N4;
        vector	_utan1 = vector();
        vector	_vtan1 = vector();
        float	_angle1 = 0.0;
        {


            connected2 = 0 ? 1 : 0;


            result134 = 1 != 0 ? _N5 : N;


            nvec8 = normalize(result134);


            quat2 = quaternion(_angle1, nvec8);


            tstyle1 = _tstyle1;


            in_utan1 = _utan1;


            in_vtan1 = _vtan1;


            nml1 = nvec8;


            result135 = 0 != 0 ? _uv26 : uv;


            uv28 = result135;


            vop_computeTangents(tstyle1, nml1, uv28, in_utan1, in_vtan1, utan1, vtan1);


            result136 = qrotate(quat2, utan1);
#line 5583 "/mat/megascans_shader_simple1/SurfaceVexCode"
                result137 = (0 != 0 ? (connected2 != 0 ? utan1 : result136)
                                          : (connected2 != 0 ? result136 : utan1));




            result138 = qrotate(quat2, vtan1);
#line 5601 "/mat/megascans_shader_simple1/SurfaceVexCode"
                result139 = (0 != 0 ? (connected2 != 0 ? vtan1 : result138)
                                          : (connected2 != 0 ? result138 : vtan1));




            _utan1 = result137;
            _vtan1 = result139;
        }


        found22 = renderstate("global:bake_normalsfaceforward", val22);
        if (!found22) val22 = 0;


        faceforward = val22;


        vector	__uv = _uv25;
        int	_usemikkt = usemikkt;
        int	_ntflipx = ntflipx;
        int	_ntflipy = ntflipy;
        int	_ntincludedisp = ntincludedisp;
        vector	__N = _N4;
        string	_uvobject = uvobject;
        string	_uvhiresobject = uvhiresobject;
        vector	__utan = _utan1;
        vector	__vtan = _vtan1;
        int	_unwrapmethod = unwrapmethod;
        int	_flipnormal = flipnormal;
        int	_faceforward = faceforward;
        int	_isuvrender = isuvrender;
        vector	tangentN = vector();
        vector	nN = vector();
        {


            Ni = {0, 0, 0};


            vector Ni_p;
            int Ni_f = dimport("pre_disp_N", Ni_p);

            vector nn_p;
            vector utan_p;
            vector vtan_p;
            int nn_f = dimport("pre_disp_N", nn_p);
            int utan_f = dimport("pre_disp_utan", utan_p);
            int vtan_f = dimport("pre_disp_vtan", vtan_p);

            if (_uvhiresobject == "")
            {
                Ni = __N;
            }
            else
            {
                if (!_ntincludedisp && Ni_f)
                {
                    Ni = __N * dihedral(normalize(N), nn_p);
                }
                else
                {
                    Ni = __N;
                }
            }




            nn = {0, 0, 0};
            utan2 = {0, 0, 0};
            vtan2 = {0, 0, 0};


            vector nn_p1;
            vector utan_p1;
            vector vtan_p1;
            int nn_f1 = dimport("pre_disp_N", nn_p1);
            int utan_f1 = dimport("pre_disp_utan", utan_p1);
            int vtan_f1 = dimport("pre_disp_vtan", vtan_p1);

            if (_isuvrender && _usemikkt)
            {
                vector mikkN = 0;
                vector mikkT = 0;
                vector mikkB = 0;
                getsamplestore("uvlens_mikkt_n", Eye, mikkN);
                getsamplestore("uvlens_mikkt_u", Eye, mikkT);
                getsamplestore("uvlens_mikkt_v", Eye, mikkB);

                utan2 = cross(mikkB, mikkN);
                vtan2 = cross(mikkN, mikkT);
                nn = cross(mikkT, mikkB);
                if (dot(mikkT, utan2) < 0)
                {
                    nn *= -1;
                    utan2 *= -1;
                    vtan2 *= -1;
                }
            }
            else if (_uvhiresobject == "")
            {
                if (_ntincludedisp && nn_f1 && utan_f1 && vtan_f1)
                {
                    nn = nn_p1;
                    utan2 = utan_p1;
                    vtan2 = vtan_p1;
                }
                else
                {
                    nn = normalize(N);
                    utan2 = __utan;
                    vtan2 = __vtan;
                }
            }
            else
            {
                nn = normalize(-I);
                vector resultn;
                getuvtangents(_uvobject, Eye, nn, utan2, vtan2, resultn);
                nn = resultn;
            }




            if (dot(Ni,nn) < 0)
                Nf1 = -Ni;
            else
                Nf1 = Ni;


            if( _faceforward == 0 )
                result140 = Ni;
            else
                result140 = Nf1;


            vector nn0 = (1 != 0) ? nn : normalize(N);
            vector ut = 0;
            vector vt = 0;
            vop_computeTangents("inputs", nn0, vector(), utan2, vtan2, ut, vt);
            tangentN1 = vop_tangentNormal(result140, nn0, ut, vt, 1, _ntflipx, _ntflipy, 1);


            vector nn01 = (1 != 0) ? nn : normalize(N);
            vector ut1 = 0;
            vector vt1 = 0;
            vop_computeTangents("inputs", nn01, vector(), utan2, vtan2, ut1, vt1);
            tangentN2 = vop_tangentNormal(result140, nn01, ut1, vt1, 0, _ntflipx, _ntflipy, 1);


            nN1 = tangentN2;


            tangentN = tangentN1;
            nN = nN1;
        }


        result141 = 1 != 0 ? _export_normal : nN;


        export_normal = result141;


        found23 = renderstate("global:bake_samples", val23);
        if (!found23) val23 = 16;


        samples = val23;


        Oc1 = 0;
        gather(P, normalize(N),
               "angle", radians(90.0),
               "samples", samples)
        {
            Oc1 += 1;
        }
        Oc1 = 1 - Oc1 / samples;


        found24 = renderstate("global:bake_occlusionbias", val24);
        if (!found24) val24 = 0.5;


        occlusionbias = val24;
#line 5811 "/mat/megascans_shader_simple1/SurfaceVexCode"
           bias4 = vop_bias(Oc1, occlusionbias);




        vec5 = set(bias4,bias4,bias4);


        result142 = 1 != 0 ? _export_ao : vec5;


        export_ao = result142;


        found25 = renderstate("global:bake_cavitydistance", val25);
        if (!found25) val25 = 1;


        cavitydistance = val25;


        Cv1 = 0;
        gather(P, -normalize(N),
               "angle", radians(90.0),
               "samples", samples,
               "maxdist", cavitydistance,
               "scope", "scope:default")
        {
            Cv1 += 1;
        }
        Cv1 = 1.0 - Cv1 / samples;


        found26 = renderstate("global:bake_cavitybias", val26);
        if (!found26) val26 = 0.5;


        cavitybias = val26;
#line 5871 "/mat/megascans_shader_simple1/SurfaceVexCode"
           bias5 = vop_bias(Cv1, cavitybias);




        vec6 = set(bias5,bias5,bias5);


        result143 = 1 != 0 ? _export_ior : vec6;


        export_ior = result143;


        result144 = 1 != 0 ? _export_speccolor : { 0, 0, 0 };


        export_speccolor = result144;


        result145 = 1 != 0 ? _export_translucency : { 0, 0, 0 };


        export_translucency = result145;


        result146 = 0 != 0 ? _export_sss : { 0, 0, 0 };


        export_sss = result146;


        result147 = 0 != 0 ? _export_emission : { 0, 0, 0 };


        export_emission = result147;


        result148 = 1 != 0 ? _export_rough : 0;


        export_rough = result148;


        result149 = 1 != 0 ? _export_metallness : 0;


        export_metallness = result149;


        result150 = 0 != 0 ? _export_mask : 0;


        export_mask = result150;


        result151 = 0 != 0 ? _export_fuzz : 0;


        export_fuzz = result151;


        string	_mode13 = "uv";
        vector	uv29 = vector();
        float	u13 = 0.0;
        float	v13 = 0.0;
        float	w13 = 0.0;
        {


            bool47 = (_mode13 == "st");


            bound_uv13 = isbound("uv");


            bound_st13 = isbound("st");



            uv30 = set(s, t, 0);





            output113 = st;


            if( bound_st13 == 0 )
                result152 = uv30;
            else
                result152 = output113;


            if( bound_uv13 == 0 )
                result153 = result152;
            else
                result153 = uv;


            if( bool47 == 0 )
                result154 = result153;
            else
                result154 = uv30;


            assign(fval122,fval222,fval322, result154);


            uv29 = result154;
            u13 = fval122;
            v13 = fval222;
            w13 = fval322;
        }


        result155 = 1 != 0 ? _uv25 : uv29;


        result156 = 1 != 0 ? result155 : { 0, 0, 0 };


        export_uv = result156;


        result157 = 1 != 0 ? _export_bump : { 0, 0, 0 };


        export_bump = result157;


        result158 = 1 != 0 ? _export_opacity : { 1, 1, 1 };


        export_opacity = result158;


        layer6 = _layer2;


        result159 = 1 != 0 ? _export_diffcolor : { 0, 0, 0 };


        export_diffcolor1 = result159;


        export_rough1 = result148;


        export_ior1 = result143;


        export_metallness1 = result149;


        export_speccolor1 = result144;


        export_translucency1 = result145;


        export_sss1 = result146;


        export_emission1 = result147;


        export_mask1 = result150;


        export_fuzz1 = result151;


        export_uv2 = result156;


        export_dispcolor1 = result132;


        export_normal1 = result141;


        export_bump1 = result157;


        export_ao1 = result142;


        export_opacity1 = result158;


        outlayer = layer6;
        outexport_diffcolor = export_diffcolor1;
        outexport_rough = export_rough1;
        outexport_ior = export_ior1;
        outexport_metallness = export_metallness1;
        outexport_speccolor = export_speccolor1;
        outexport_translucency = export_translucency1;
        outexport_sss = export_sss1;
        outexport_emission = export_emission1;
        outexport_mask = export_mask1;
        outexport_fuzz = export_fuzz1;
        outexport_uv = export_uv2;
        outexport_dispcolor = export_dispcolor1;
        outexport_normal = export_normal1;
        outexport_bump = export_bump1;
        outexport_ao = export_ao1;
        outexport_opacity = export_opacity1;

        _mat_megascans_shader_simple1_asset_bake_exports1_add_layer_exports(outlayer, outexport_diffcolor, outexport_rough, outexport_ior, outexport_metallness, outexport_speccolor, outexport_translucency, outexport_sss, outexport_emission, outexport_mask, outexport_fuzz, outexport_uv, outexport_dispcolor, outexport_normal, outexport_bump, outexport_ao, outexport_opacity);


        _layer2 = outlayer;


        Oc = vec5;


        Cv = vec6;


        Cf1 = {0,0,0};

        float th = 0;
        float rl = 0;
        gather(P, -normalize(N),
               "angle", radians(90.0),
               "samples", samples,
               "scope", "scope:default",
               "ray:length", rl)
        {
            th += rl;
        }
        th *= 1.0 / samples;
        Cf1 = th;



        Th = Cf1;



          blend1 = lerp({ 0, 0, 0 }, { 1, 1, 1 }, 0.5);





        Ab = blend1;


        found27 = renderstate("global:bake_curvaturescale", val27);
        if (!found27) val27 = 1;


        curvaturescale = val27;


        found28 = renderstate("global:bake_curvaturebias", val28);
        if (!found28) val28 = 0.5;


        curvaturebias = val28;


        found29 = renderstate("global:bake_curvatureocc", val29);
        if (!found29) val29 = 0;


        curvatureOcc = val29;


        found30 = renderstate("global:bake_curvaturesdist", val30);
        if (!found30) val30 = 0.10000000000000001;


        curvatureSDist = val30;


        float convex = 0;
        float concave = 0;

        if (curvatureOcc)
        {


            vector dir = normalize(N);



            vector off = dir * curvatureSDist * 0.02;
            float raylen;
            gather(P-off, -dir,
                   "angle", radians(90.0),
                   "samples", samples,
                   "distribution", "uniform",
                   "scope", "scope:default",
                   "maxdist", curvatureSDist,
                   "ray:length", raylen
                   )
            {
                convex += 1.0 - raylen/curvatureSDist;
            }
            convex *= curvaturescale / samples;

            gather(P+off, dir,
                   "angle", radians(90.0),
                   "samples", samples,
                   "distribution", "uniform",
                   "scope", "scope:default",
                   "maxdist", curvatureSDist,
                   "ray:length", raylen
                   )
            {
                concave += 1.0 - raylen/curvatureSDist;
            }
            concave *= curvaturescale / samples;
        }
        else
        {
            vector localCurvature = getlocalcurvature(s, t);

            convex = (localCurvature.x + curvatureConvex) * curvaturescale * 0.01;
            concave = (localCurvature.y + curvatureConcave) * curvaturescale * 0.01;
        }

        K = (vop_bias(convex, curvaturebias) - vop_bias(concave, curvaturebias)) * 0.5 + 0.5;


        vec7 = set(K,K,K);


        Cu = vec7;


        Vd1 = {0,0,0};

        if (isuvrender)
        {
            vector ray_org_l1 = 0;
            getsamplestore("uvlens_ray_org_l", Eye, ray_org_l1);
            vector ray_org_h = 0;
            getsamplestore("uvlens_ray_org_h", Eye, ray_org_h);
            Vd1 = ray_org_h - ray_org_l1;
        }


        Vd = Vd1;


        Nt = tangentN;


        Ds = Ds1;


        string	_uvobject1 = uvobject;
        string	_uvhiresobject1 = uvhiresobject;
        int	_ntincludedisp1 = ntincludedisp;
        vector	__utan1 = _utan1;
        vector	__vtan1 = _vtan1;
        int	_isuvrender1 = isuvrender;
        vector	utan3 = vector();
        vector	vtan3 = vector();
        vector	nn1 = vector();
        {


            nn2 = {0, 0, 0};
            utan4 = {0, 0, 0};
            vtan4 = {0, 0, 0};

            if (_isuvrender1)
            {

                vector nn_p2;
                vector utan_p2;
                vector vtan_p2;
                int nn_f2 = dimport("pre_disp_N", nn_p2);
                int utan_f2 = dimport("pre_disp_utan", utan_p2);
                int vtan_f2 = dimport("pre_disp_vtan", vtan_p2);

                if (_uvhiresobject1 == "")
                {
                    if (_ntincludedisp1 && nn_f2 && utan_f2 && vtan_f2)
                    {
                        nn2 = nn_p2;
                        utan4 = utan_p2;
                        vtan4 = vtan_p2;
                    }
                    else
                    {
                        nn2 = normalize(N);
                        utan4 = __utan1;
                        vtan4 = __vtan1;
                    }
                }
                else
                {
                    vector ray_org_l2 = 0;
                    getsamplestore("uvlens_ray_org_l", Eye, ray_org_l2);
                    vector dir1 = normalize(-I);
                    getuvtangents(_uvobject1, ray_org_l2, dir1, utan4, vtan4, nn2);
                }
            }




            utan3 = utan4;
            vtan3 = vtan4;
            nn1 = nn2;
        }


        matx1 = set(utan3, vtan3, nn1);





          inverse5 = invert(matx1);



        product26 = Vd1 * inverse5;


        Vdt = product26;


        export_diffcolor = result159;
    }


    layer = _layer2;


    vector tempOf = result13;
    bsdf tempF = result108;
    Of = tempOf;
    F = tempF;
}
